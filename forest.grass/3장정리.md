# 3장 정리

## 개요
- HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같다.
- 메시지가 어떻게 흘러가는가
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 메시지 흐름
- HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.
- 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.
- 이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.
- 메시지 방향
    - 인바운드, 아웃바운드, 업스트림, 다운스트림

## 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 인바운드
    - 메시지가 원 서버로 향하는 것은 
- 아웃바운드
    - 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는것

## 다운스트림으로 흐르는 메시지
- 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.
- 메시지의 발송자는 수신자의 업스트림이다.

## 메시지의 각부분
- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- 메시지는 시작줄, 헤더 블록, 본문 이렇게 세부분으로 이루어진다.
- 시작줄과 헤더는 그냥 줄단위로 분리된 아스키 문자열이다.
- 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다.
- 엔티티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리다.

## 메시지 문법
- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.
- 요청 메시지
    - 웹서버에 어떤 동작을 요구한다.
- 응답 메시지
    - 요청의 결과를 클라이언트에게 돌려준다.
- 메서드
    - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
- 요청 URL
    - 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성이다.
- 버전
    - 이 메시지에서 사용 중인 HTTP의 버전이다
- 상태 코드
    - 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다.
- 사유 구절
    - 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
- 헤더들
    - 이름, 콜론, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들, 이 헤더의 목록은 빈줄로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.
- 엔터티 본문
    - 엔터티 본문은 임의의 데이터 블록을 포함한다.
- 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄로 끝나야 함에 주의하라.
- 널리 쓰이지만 규칙을 잘 지키지 않은 구현체와의 호환을 위해, 클라이언트와 서버는 마지막 CRLF 없이 끝나는 메시지도 받아들일 수 있어야 한다.

## 시작줄
- 요청줄
    - 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다.
    - 어떤 동작이 일어나야 하는지, 대상을 지칭하는 요청 URL, HTTP 버전
- 응답줄
    - 수행 결과에 대한 상태 정보를 돌려준다.
    - HTTP 버전, 상태 코드, 사유 구절
- 메서드
    - 요청의 시작은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
    - GET, HEAD, POST, PUT, TRACE, OPTIONS, DELETE 등
    - HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수도 있다.(확장 메서드)
- 상태 코드
    - 메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언에게 무엇이 일어났는지 말해준다.
    - 1xx, 2xx, 3xx, 4xx, 5xx
    - 인식할 수 없는 상태코드를 받게 되면, 누군가가 현재 프로토콜의 확장으로 그것을 정의 했을 가능성이 있다.
    - 그 상태 코드를 그것이 포함되는 범주의 일반적인 구성원으로 가정하고 다루어야 한다.
- 사유 구절
    - 상태 코드에 대한 글로 된 설명을 제공한다.
    - 사유 구절은 상태 코드와 일대일로 대응한다.
    - 사람이 이해하기 쉬운 버전이다.
- 버전 번호
    - 버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
    - 이것은 HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.
    - HTTP/1.0 애플리케이션이 버전 번호가 HTTP/1.1로 된 응답을 받았을 때, 이를 HTTP/1.1 메시지라고 해석하면 안된다.(HTTP/1.0 애플리케이션은 HTTP/1.1을 이해할 수 없기 때문이다.)

## 헤더
- 시작줄 다음에는 0개, 1개 혹은 여러개의 HTTP 헤더가 온다.
- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적을 이름/값 쌍의 목록이다.
- 일반 헤더
    - 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더
    - 요청에 대한 부가 정보를 제공
- 응답 헤더
    - 응답에 대한 부가 정보를 제공
- Entity 헤더
    - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더
    - 명세에 정의되지 않은 새로운 헤더
- 헤더를 여러 줄로 나누기
    - 긴 헤더 줄은 그들을 여러 줄로 쪼개서 더 잃기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭문자가 와야 한다.

## 엔터티 본문
- HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문이다.
- 엔터티 본문은 HTTP 메시지의 화물이라고 할 수 있다.
- HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

## 버전 0.9 메시지
- HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다. 단순한 프로토콜로 되어 있다.
- HTTP/0.9 메시지도 마찬가지로 요청과 응답으로 이루어져 있지만, 요청은 그저 메서드와 요청 URL를 갖고 있을 뿐이며, 응답은 오직 엔터티로만 되어 있다.
- 버전 정보도 없고, 상태 코드나 사유 구절도 없으며, 헤더도 포함되어 있지 않다.
- 단순함, 다양한 상황에 대처가 불가능

## 메서드
- 모든 서버가 모든 메서드를 구현하지는 않는다는 것에 주의하라
- 비록 서버가 모든 메서드를 구현하지 않았다 하더라도 메서드는 대부분 제한적으로 사용될 것이다.

## 안전한 메서드
- HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다.
- GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
- 작용이 없다는 것은, HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미이다.
- 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다.
- 안전 메서드의 목적
    - 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

## GET
- GET은 가장 흔히 쓰이는 메서드다.
- 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

## HEAD
- HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.
- 엔터티 본문은 결코 반환되지 않는다.
- 이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.
- HEAD 사용이유
    - 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
    - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
    - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
- 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

## PUT
- PUT 메서드는 서버에 문서를 쓴다.
- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.
- PUT은 콘텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것이다.

## POST
- POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다.
- 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳에 보낸다.

## TRACE
- 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다.
- 이들에게는 원래 HTTP 요청을 수정할 수 있는 기회가 있다.
- 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
- TRACE 요청은 목적 서버에서 ‘루프백’ 진단을 시작한다.(어떻게 변경되었는지 확인이 가능하다)
- TRACE 메서드는 주로 진단을 위해 사용된다.
- 많은 HTTP 애플리케이션은 메서드에 따라 다르게 동작한다.
- TRACE는 메서드를 구별하는 메커니즘을 제공하지 않는다. 어떻게 TRACE 요청을 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션이 결정을 내린다.
- TRACE 요청은 어떤한 엔터티 본문도 보낼 수 없다. 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.

## OPTIONS
- OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.
- 메서드는 여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공한다.

## DELETE
- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
- 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 왜냐하면 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

## 확장 메서드
- HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.
- 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다.
- 모든 확장 메서드가 형식을 갖춘 명세로 정의된 것은 아니라는 점에 주의해야 한다.

## 상태 코드
- HTTP 상태 코드는 크게 다섯 가지로 나뉜다.
- 상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

## 100-199 - 정보성 상태코드
- 정보성 상태코드는 HTTP/1.1에서 도입되었다.
- 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입된 것이다.
- 클라이언트와 100 Continue
- 서버와 100 Continue
- 프락시와 100 Continue

## 200-299 - 성공 상태 코드
- 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.
- 책 p.70 표 참고

## 300-399 - 리다이렉션 코드
- 리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.
- 리다이렉션 상태 코드는 중 몇명은 리소스에 대한 애플리케이션의 로컬 복사복이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.
- 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.
- 책 p.72 표 참고
- HTTP/1.0과 HTTP/1.1의 302, 303, 307

## 400-499 - 클라이언트 에러 상태 코드
- 클라이언트는 서버가 다룰 수 없는 무엇인가를 보낸다.
- 잘못 구성된 요청 메시지 같은 것이 있을 수 있으며, 가장 흔한 것은 존재하지 않은 URL에 대한 요청이다.
- 책 p.74 표 참고

## 500-599 - 서버 에러 상태 코드
- 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다.
- 이것은 클라이언트가 서버의 제한에 걸린 것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.
- 책 p.76 표 참고

## 헤더
- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.
- 일반 헤더
    - 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다.
    - 이들은 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.
- 요청 헤더
    - 요청 메시지를 위한 헤더다.
    - 클라이언트가 받고자 하는 데이터 타입이 무엇인지와 같은 부가 정보를 제공한다.
- 응답 헤더
    - 응답 메시지는 클라이언트에게 정보를 제공하기 위한 자시만의 헤더를 갖고 있다.
- 엔터티 헤더
    - 엔터티 헤더라 엔터티 본문에 대한 헤더를 말한다.
    - 엔터티 헤더는 엔터티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다.
- 확장 헤더
    - 확장 헤더는 애플리케이션 개발들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더다.

## 일반헤더
- 메시지에 대한 아주 기본적인 정보를 제공한다.
- 일반 캐시 헤더
- 책 p.78 표 참고

## 요청 헤더
- 요청 메시지에서만 의미를 갖는 헤더다.
- Accept 관련 헤더
    - 책 p.79 표 참고
- 조건부 요청 헤더
    - 책 p.80 표 참고
- 요청 보안 헤더
    - 책 p.80 표 참고
- 프락시 요청 헤더
    - 책 p.81 표 참고

## 응답 헤더
- 응답 헤더는 클라이언트에게 부가 정보를 제공한다.
- 책 p.81 표 참고
- 협상헤더
    - 책 p.82 표 참고
- 응답 보안 헤더
    - 책 p.82 표 참고

## 엔터티 헤더
- HTTP 메시지의 엔터티에 대해 설명하는 헤더다.
- 책 p.83 표 참고
- 콘텐츠 헤더
    - 책 p.83 표 참고
- 엔터티 캐싱 헤더
    - 책 p.84 표 참고

## 정리
- HTTP 버전의 중요성을 알게 된거 같다. 버전에 지원하는 헤더, 메서드등이 있기 때문이다.
- 헤더들을 다 외우기는 힘들다고 생각한다. 크게 다섯가지 헤더 정의만 기억해두고 필요할때 보면서 사용해야 할 것 같다.
- HTTP 메서드 PUT을 RESTFulAPI로 이용하게 되면 갱신으로만 바라고 보고 사용해야 한다고 생각한다.
- 최근 서블릿 컨테이너를 공부하면서  CRLF를 많이 보았다.  CRLF을 통하여 헤더들을 파싱하고 분석하는 코드였던걸로 기억한다.
