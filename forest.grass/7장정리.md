# 7장 정리

## 개요
- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.
- 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
- 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있게 된다.
- 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
- 페이즈를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

## 불필요한 데이터 전송
- 캐시를 이용하면, 서버 응답은 캐시에 보관된다.
- 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고 받는 낭비가 줄어들게 된다.

## 대역폭 병목
- 캐시는 또한 네트워크 병목을 줄여준다.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다.

## 갑작스러운 요청 쇄도
- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
- 갑자스런 사건으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 이런일이 발생한다.
- 이 결과로 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킨다.

## 거리로 인한 지연
- 비록 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있다. 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.
- 그리고 클라이언트와 서버 사이에 라우터가 그다지 많지 않더라도, 빛의 속도 그 자체가 유의미한 지연을 유발한다.

## 적중과 부적중
- 캐시가 모든 문서의 사본을 저장하지는 않는다.
- 캐시 적중
    - 캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다.
- 캐시 부적중
    - 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐이다.

## 재검사
- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신이지 서버를 통해 때때로 점검해야 한다.
- 이러한 신선도 검사를 HTTP 재검사라 부른다.
- 효과적인 재검사를 위해, HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의 했다.
- 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 오래된 경우에만 재검사를 한다.
- 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다.
- 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보낸다.
- 이를 재검사 적중 혹은 느린 적중이라고 부른다. 이것은 수순 캐시 적중보다 느린데, 원 서버와 검사를 할필요가 있기 때문이다.
- 그러나 캐시 부적중보다는 빠른데, 서버로부터 객체 데이터를 받아올 필요가 없기 때문이다.
- HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그중에서 가장 많이 쓰이는 것은 If-Modified-Since 헤더다.

## GET If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황
- 재검사 적중
    - 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보낸다.
- 재검사 부적중
    - 만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보낸다.
- 객체 삭제
    - 만약 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제한다.

## 적중률
- 캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부르기도 한다.
- 적중률은 0에서 1까지의 값으로 되어 있지만, 흔히 퍼센트로 표현되기도 한다. 
- 0%는 모든 요청이 캐시 부적중임을, 그리고 100%는 모든 요청이 캐시 적중임을 의미한다.
- 적중률이 40%면 괜찮은 편이다.
- 보통 크기의 캐시라도 충분한 분량의 자주 쓰이는 문서들을 보관하면 상당히 트래픽을 줄이고 성능을 개선할 수 있다.

## 바이트 적중률
- 문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않는다.
- 몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여한다.
- 이런 이유로, 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다.
- 문서 적중률을 개선하면 전체 대기시간이 줄어든다.
- 바이트 단위 적중률의 개선은 대역폭 절약을 최적화한다.

## 적중과 부적중의 구별
- 불행히도, HTTP 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것이다.(현재시각과 Date 헤더 비교)

## 캐시 토폴로지
- 캐시는 한 명의 사용자에게만 할당될 수도 있고 반대로 수천 명의 사용자들 간에 공유될 수도 있다.
- 한명에게만 할당된 캐시를 개인전용 캐시라 부른다.
- 공유된 캐시는 공유 캐시라고 부른다.

## 개인 전용 캐시
- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있다.
- 웹 브라우저는 개인 전용 캐시를 내장하고 있다.

## 공용 프락시 캐시
- 공용 캐시는 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근한다.

## 프락시 캐시 계층들
- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 ‘걸러 남겨진’ 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
- 프락시 연쇄가 길어질수록 중간 프락시는 현저한 성능 저하가 발생할 것이다.

## 캐시망, 콘텐츠 라우팅, 피어링
- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.
- 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적을 내린다.
- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 다음에 나열 된 일들을 모두 할 수 있다.
    - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
    - URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
    - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
    - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않는다.

## 캐시 처리 단계
- 오늘늘 상용 프락시 캐시는 꽤 복잡하다. 매우 고성능이면서도 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어졌다.
- 캐시 처리 절차(p.199 ~ p.200)
    - 1. 요청 받기
    - 2. 파싱
    - 3. 검색
    - 4. 신선도 검사
    - 5. 응답 생성
    - 6. 발송 
    - 7. 로깅

## 사본을 신선하게 유지하기
- 캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아니다.
- 결국 문서들은 시간에 따라 변경된다. 보고서는 매달 바뀔 수 있다. 온라인 신문은 매일 바뀐다.
- 금융 자료는 매초 변경될 수 있다. 오래된 데이터를 제공하는 캐시는 불필요하다. 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.

## 문서 만료
- HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 문서에 유효기간을 붙일 수 있게 해준다.
- 캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있다.

## 유효기간과 나이
- 서버는 응답 본문과 함께 하는, HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해서 유효기간을 명시한다.
- p.202

## 서버 재검사
- 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않으며, 다만 이제 검사할 시간이 되었음을 뜻한다.
- 이 검사를 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음을 의미하는 서버 재검사라고 부른다.
- HTTP 프로토콜은 캐시 다음 중 하나를 반환하는 적절한 행동을 할 것을 요구한다.
    - 충분히 신선한 캐시된 사본
    - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확실할 수 있는 캐시된 사본
    - 에러 메시지
    - 경고 메시지가 부탁된 캐시된 사본

## 조건부 메서드와의 재검사
- HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.
- 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다.
- HTTP는 다섯 가지 조건부 요청 헤더를 정의한다.
- 그 중 둘은 캐시 재검사를 할 때 가장 유용한 If-Modified-Since와 If-None-Match이다.
- P.204

## If-Modified-Since: 날짜 재검사
- 가장 흔히 쓰이는 캐시 재검사 헤더는 If-Modified-Since이다.
- If-Modified-Since 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.
- If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작한다.
- If-Modified-Since와 최근 변경일 간의 문자열 비교를 수행한다.(정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면)

## If-None-Match: 엔터티 태그 재검사
- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황이 몇 가지 있다.
    - 내용에는 아무런 변화가 없더라도 변경시각은 바뀔수 있다.
    - 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수도 있다.
    - 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다.
    - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.
- 퍼블리셔가 문서를 변경했을 때, 그는 문서의 엔터티 태그를 새로운 버전으로 표현할 수 있다.
- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 그 사실을 서버에게 알리기 위해 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있다.

## 약한 검사기와 강한 검사기
- 캐시는 캐시된 버전이 서버가 갖고 잇는 것에 대해 최신인지 확인하기 위해 엔터티태그를 사용한다.
- 이 경우, 엔터티 태그와 최근 변경일시는 둘 다 캐시 검사기다.
- 약한 검사기
    - 서버는 때때로 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있다.
    - HTTP/1.1은, 비록 콘텐츠가 조금 변경되었더라도 그 정도면 같은 것이라고 서버가 주장할 수 있도록 해준다.
    - 서버는 ‘w/‘ 접두사로 약한 검사기를 구분한다.
    - 약한 엔터티 태그는 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경되어야 한다.
- 강한 검사기
    - 콘텐츠가 바뀔 때마다 바뀐다.
    - 강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 한다.
- 원 서버는 서로 다른 두엔터티에 대한 강한 엔터티 태그 값을 재활용해서는 안되며, 약한 엔터티 태그 값이라고 할지라도 서로 의미가 다른 두 엔터티에 대해서는 재활용해서는 안되는 것에 주의하라.

## 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
- 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 한다.
- 서버가 Last-Modified 값만을 반한했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.
- 엔터티 태그와 최근 변경일시가 모두 사용가능하다면, HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 클라이언트는 각각을 위해 두 가지의 재검사 정책을 모두 사용해야 한다.
- 서버는 엔터티 태그를 사용할 수 있다면 되도록 사용하고 Last-Modified 또한 가능하다면 추가해서 보내주자.
- 캐시는 엔터티 태그와 If-Modified-Since 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반한해서는 안 된다.

## 캐시 제어
- HTTP 문서는 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의한다.
    - Cache-Control : no-store
    - Cache-Control : no-cache
    - Cache-Control : must-revalidate
    - Cache-Control : max-age
    - Expires 날짜 헤더
    - 휴리스틱 방법

## no-cache와 no-store 응답 헤더
- HTTP/1.1은 신선도를 관리하기 위해, 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러 가징 방법을 제공한다.
- no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.
- ‘no-store’가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다. 캐시는 보통, 캐시가 아닌 프락시 서버가 그러는 것처럼, 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것이다.
- ‘no-cache’로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을뿐이다.

## Max-Age 응답 헤더
- Cache-Control : max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다.
- s-maxage 헤더는 max-age처럼 행동하지만 공유된 캐시에만 적용된다.
- 서버는 최대 나이먹음을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

## Expires 응답 헤더
- 더 이상 사용하지 않기를 권하는 Expires 헤더는 초 단위의 시간 대신 실제 만료 날짜를 명시한다.

## Must-Revalidate 응답 헤더
- 캐시는 성능을 개선하기 위해 신선하지 않은 객체를 제공하도록 설정될 수 있다.
- 만약 캐시가 만료 정보를 엄격하게 따르기 원한다면, 원 서버는 다음과 같은 Cache-Control : must-revalidate를 붙일 수 있다.
- Cache-Control : must-revalidate 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와 최초의 재검사 없이는 제공해서 안 됨을 의미한다.

## 휴리스틱 만료
- 응답이 Cache-Control : max-age 헤더나 Expires 헤더 중 어는 것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로 최대 나이를 계산 할 수 있다.
- 어떤 알고리즘이든 사용될 수 있지만, 계산 결과 얻은 최대 나이 값이 24시간보다 크다면, Heuristic Expiration 경고 헤더가 응답 헤더에 추가되어야 한다.
- 휴리스틱 신선도 계산은 생가보다 흔히 하게 되는 일이다. 많은 원 서버들이 아직도 Expires와 max-age 헤더를 생성하지 못한다.
- 캐시의 만료 기본값을 신중하게 선택하자.

## LM인자 알고리즘
- 유명한 휴리스틱 만료 알고리즘 중 하나
- 만약 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면, 그것은 아마 안정적인 문서일 것이고 갑자기 바뀔 가능성은 별로 크지 않을 것이므로, 캐시에 더 오래 보관하고 있어도 안전하다.
- 만약 캐시된 문서가 최근에 변경되었다면, 그것은 아마 자주 변경될 것이고, 따라서 우리는 그것을 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 한다.

## 클라이언트 신선도 제약
- 웹 브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼을 갖고 있다.
- 이 리프레시 버튼은 Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
- 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 달려 있다.

## 주의 할점
- 문서 만료는 완벽한 시스템이 아니다. 만약 퍼플리셔가 잘못해서 유효기간을 까마득한 미래로 설정해버린다면, 만료되기 전까지는 그 문서에 대한 어떤 변경도 캐시에 반영되지 않을 것이다.

## 캐시 제어 설정
- 웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공한다.

## 아파치로 HTTP 헤더 제어하기
- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공한다.
- 이 메커니즘들 중 많은 것이 디폴트로는 가능하지 않게 되어 있어서 사용하려면 일단 활성화시킬 필요가 있다.

## 아파치로 HTTP 헤더 제어하기 - mod-headers
- mod_headers 모듈은 개별 헤더들을 설정할 수 있게 해준다.
- 한번 이 모듈이 로드되면, 개별 HTTP 헤더를 설정할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가할 수 있다.

## 아파치로 HTTP 헤더 제어하기 - mod_expires
- mod_expires 모듈은 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공한다.
- 이 모듈은 문서에 마지막으로 접근한 날 혹은 수정한 날 이후의 일정 시한으로 유효기간을 설정할 수 있게 해준다.

## 아파치로 HTTP 헤더 제어하기 - mod_cern_meta
- mod_cern_meta 모듈은 HTTP 헤더들의 파일을 특정 객체와 연결시켜준다.
- 이 모듈을 켜면 제어하고자 하는 파일에 각각 대응되는 메타파일들을 생성하게 되므로, 각 메타파일에 원하는 헤더를 추가하면 된다.

## HTTP-EQUIV를 통한 HTML 캐시 제어
- HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용된다.
- 웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용한다.
- 불행히도 이 기능을 지원하는 웹 서버나 프락시는 거의 없다. 왜냐하면 이 기능은 서버의 부하를 가중시키고, 설정값이 정적이고, HTML을 제외한 다른 타입의 파일은 지원하지 않기 때문이다.
- 문서의 캐시 제어 요청과 커뮤니케이션하는 유일하게 확실한 방법은 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것이다.

## 자세한 알고리즘
- HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는, 자세하지만 조금 이해하기 어렵고 종종 혼란스러운 알고리즘을 제공한다.
- 나이와 신선도 수명
- 나이 계산
- 겉보기 나이는 Date 헤더에 기반한다.
- 점층적 나이 계산
- 네트워크 지연에 대한 보상
- 완전 나이 계산 알고리즘
    - 요청의 네트워크 지연 + 서버가 처리하는 시간 + 응답의 네트워크 지연 + 캐시에 체류한 시간
- 신선도 수명 계산

## 캐시와 광고
- 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다.
- 캐싱이 완벽하게 동작한다면 원 서버는 HTTP 접근을 전혀 수신하지 않게 된다.
- 인터넷 캐시가 그 접근들을 모두 흡수하기 때문이다. 만약 접근 횟수에 따라 돈을 벌고 있다면, 이는 달갑지 않은 일이 것이다.
- 해결법
    - 모든 접근에 대해 원 서버와 재검사하도록 캐시를 설정
    - 로그 마이그레이션
    - 적충 측정과 사용량 제한(적중 횟수를 정기적으로 서버에게 돌려주는 Meter라고 하는 헤더를 이용)
