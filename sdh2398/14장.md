# 보안 HTTP

### HTTP를 안전하게 만들기
사람들은 웹 트랜잭션을 중요한 일에 사용하므로 안전한 방식의 HTTP를 필요로 한다.
* 인증과 메시지 무결성을 제공하는건 쓸만하지만 보안 자료 접근을 위해서는 충분히 강력하지 않다.
* 보다 중요한 트랜잭션에는, HTTP와 디지털 암호화 기술을 결합해야 한다.

다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요하다.
* 서버 인증
* 클라이언트 인증
* 무결성
    * 위조로 부터 안전
* 암호화
    * 도청 걱정 없어야 한다.
* 효율
    * 충분히 빨라야 한다.
* 편재성(Ubiquity)
    * 거의 모든 클라와 서버에서 지원 가능해야 한다.
* 관리상 확장성
    * 누구든 어디서든 즉각적으로 할 수 있어야 한다.
* 적응성
    * 현재 알려진 최선의 보안 방법을 지원
* 사회적 생존성
    * 사회의 문화적, 정치적 요구를 만족

#### HTTPS
HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것

HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
* HTTP의 하부에 전송 레벨 암호 보안 계층을 제공
* 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL) 혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)을 이용하여 구현
    * SSL과 TLS는 매우 비슷
* 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어난다.
* TCP 입력/출력 호출을 SSL로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하면 된다.

### 디지털 암호학
* 암호
    * 텍스틑 아무나 읽지 못하도록 인코딩하는 알고리즘
* 키
    * 암호의 동작을 변경하는 숫자로 된 매개변수
* 대칭키 암호 체계
    * 인코딩과 디코딩에 같은 키를 사용
* 비대칭키 암호 체계
    * 인코딩과 디코딩에 다른 키를 사용
* 공개키 암호법
    * 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들어 낼 수 있는 시스템
* 디지털 서명
    * 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
* 디지털 인증서
    * 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

#### 비밀 코드의 기술과 과학
암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술이다.
* 암호법은 메시지를 암호화하는 것뿐 아니라, 메시지의 변조를 방지하기 위해 사용할 수도 있다.
* 누군가가 정말로 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용

#### 암호(cipher)
암호법은 암호라 불리는 비밀 코드에 기반한다.
* 암호란 메시지를 인코딩하는 어떤 방법과 나중에 비밀 메시지를 디코딩하는 방법.

#### 암호 기계
예전에는 사람이 직접 인코딩하고 디코딩해야 했기 때문에 암호가 상대적으로 간단한 알고리즘으로 시작했다.
* 기술이 진보하면서, 보다 복잡한 암호로 메시지를 빠르고 정확하게 인코딩, 디코딩하는 기계를 만들기 시작

#### 키가 있는 암호
코드 알고리즘과 기계가 적에 손에 들어갈 수 있기 때문에, 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다이얼이 달려있다.
* 기계를 훔치더라도, 다이얼이 없이는 디코더가 동작하지 않는다.
    * 실제론 기계를 손에 넣으면 암호를 깰 때 이용할 수 있는 패턴을 알 수 있다.
    * 현대의 알고리즘은 공개적으로 알려져 있다고해도 패턴을 찾기 어렵도록 설계
* 같은 인코딩 기계를 통과하더라도 키의 값에 따라 다른 출력을 생성

#### 디지털 암호
디지털 계산의 도래로, 두 가지 주요한 발전이 있었다.
* 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
* 매우 큰 키를 지원하는 것이 가능해졌다.
    * 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어 낼 수 있게 되었다.
    * 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 크래킹이 어려워진다.

기계 장치와 달리 디지털 키는 그냥 숫자에 불과하다.
* C = E(P, e)
    * C : 암호문
    * E : 인코딩 함수
    * P : 평문 메시지
    * e : 인코딩 키
* P = D(C, d)
    * D : 디코딩 함수
    * d : 디코딩 키

### 대칭키 암호법
대칭키 암호는 인코딩과 디코딩 할 때 사용하는 키가 같다.
* e = d
* 발송자와 수신자 모두 같은 비밀 키를 공유
* 잘 알려진 대칭키 암호 알고리즘은 DES, Triple-DES, RC2, RC4 등이 있다.

#### 키 길이와 열거 공격(Enumeration Attack)
대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다.
* 좋은 암호 알고리즘은 크래킹하려면 모든 가능한 키 값을 시도해보는 것 외에 다른 방법이 없게 만든다.
* 가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려있다.

#### 공유키 발급하기
대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘다 공유키를 가져야 한다는 것
* 누군가와 은밀하게 대화를 나누려면 비밀 키를 발급해줘야 한다.
    * 모든 손님의 키를 생성하고 기억해야 한다.
    * 키를 관리해야 하는 사람 입장에서 이것은 지옥이다.

### 공개키 암호법
공개키 암호 방식은 두 개의 비대칭 키를 사용한다.
* 인코딩 키는 모두를 위해 공개되어 있다.
* 하지만 호스트만이 개인 디코딩 키를 알고 있다.
* 키의 분리는, 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 디코딩하는 능력은 소유자에게만 부여
* 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.

#### RSA
공개키 비대칭 암호의 과제는, 다음 내용을 알고 있다고 해도 비밀인 개인 키를 계산할 수 없다는 걸 확신시켜 주는 것
* 공개키
    * 공개기 때문에 누구나 획득가능
* 가로채서 얻은 암호문의 일부
    * 스누핑을 통해 획득
* 메시지와 그것을 암호화한 암호문
    * 임의의 텍스트를 넣고 실행해서 획득

이 요구를 모두 만족하는 공개키 암호 체계 중 유명한 하나는 MIT에서 발명되고 이어서 RSA 데이터 시큐리티에서 상용화된 RSA 알고리즘
* RSA 구현의 코드까지 주어졌다고 하더라도 개인 키를 찾아내는 것은 큰 소수를 계산하는 문제만큼 어렵다.
* 큰 숫자를 소수들로 분해하는 빠른 방법을 찾아낸다면 스위스 은행 계좌를 뚫는 것뿐 아니라 튜링상도 받을 수 있다.

#### 혼성 암호 체계와 세션 키
공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다.
* 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.
* 공개키 암호를 사용해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 대칭 키를 사용하는 방식

### 디지털 서명
암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록하는 데에 이용될 수 있다.
* 이 기법은 인터넷 보안 인증서에게 중요하다.

#### 서명은 암호 체크섬이다
디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다. 이들은 두 가지 이점을 가진다.
* 서명은 메시지를 작성한 저자가 누군지 알려준다.
    * 저자만이 개인만이 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다.
* 서명은 메시지 위조를 방지한다.
    * 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다.
    * 체크섬은 저자의 비밀 키에 관련되어 있기 때문에, 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없다.

디지털 서명은 보통 비대칭 공개키에 의해 생성
* 저자의 개인 키는 일종의 ‘지문’처럼 사용

다음은 노드 A가 노드 B에게 메시지를 보내고 그것을 어떻게 서명하는지 보여준다.
* 노드 A가 메시지를 고정된 길이로 요약(digest)
* 그 요약에, 개인키를 매개변수로 하는 ‘서명’ 함수를 적용
* 서명이 계산되면 메시지의 끝에 덧붙이고 노드 B에게 전송
* 노드 B가 서명에 공개키를 이용한 역함수를 적용해서 얻어낸 요약과 평문 메시지를 요약한것을 비교해서 맞는지 확인
* 그림 14-10

### 디지털 인증서
인터넷 신분증인 디지털 인증서(흔히 ‘certs’라고 불리는)는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

#### 인증서의 내부
디지털 인증서에는 또한 공식적으로 ‘인증 기관’에 의해 디지털 서명된 정보의 집합이 담겨있다.
* 기본적인 디지털 인증서는 보통 다음과 같이 인쇄된 ID에도 흔히 들어가게 되는 기본적인 것들을 담고 있다.
    * 대상의 이름
    * 유효 기간
    * 인증서 발급자
    * 인증서 발급자의 디지털 서명
* 추가적으로, 사용된 서명 알고리즘과 보통 대상의 공개키도 담고 있다.
* 누구나 디지털 인증서를 만들 수 있지만, 널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다.
* 그림 14-11

#### X.509 v3 인증서
디지털 인증서에 대한 전 세계적인 단일 표준은 없다.
* 오늘날 사용되는 대부분의 인증서는 X.509라 불리는 표준화된 서식에 저장하고 있다.
* 표 14-2

X.509 기반 인증서에는 (가장 중요한)웹 서버 인증서, 클라 이메일 인증서, 소프트웨어 코드사인 인증서, 인증기관 인증서를 비롯한 몇 가지 변종이 있다.

#### 서버 인증을 위해 인증서 사용하기
HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.
* 서버가 인증서를 갖고 있지 않으면, 보안 커넥션은 실패한다.

브라우저가 인증서를 받으면, 서명 기관을 검사한다.
* 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이다.
* 서명 기관이 모르는 곳이라면, 브라우저는 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다.

### HTTPS의 세부사항
HTTPS는 HTTP의 가장 유명한 보안 버전이다.
* HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것

#### HTTPS의 개요
HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다.
* HTTP 메시지를 TCP를 통해 보내는 대신에 HTTPS는 HTTP를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다.
* 오늘날, HTTPS의 보안 계층은, SSL과 그것의 현대적 대체품인 TLS로 구현되었다.

#### HTTPS 스킴
오늘날 보안 HTTP는 선택적이다. 따라서 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줘야 한다.
* 이것은 URL의 스킴을 통해 이루어진다.
* HTTPS URL의 스킴 접두사는 https
* 웹 브라우저 등의 클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다.
* 만약 URL이 https 스킴을 갖고 있다면, 클라는 서버에 443번(기본값) 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 ‘핸드셰이크’를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.

SSL 트래픽은 바이너리 프로토콜이기 때문에, HTTP와는 완전히 다르다.
* SSL과 HTTP 트래픽 모두가 80번 포트로 도착한다면, 잘못된 HTTP로 해석하고 커넥션을 닫는다.

#### 보안 전송 셋업
* 클라는 먼저 웹 서버의 443 포트(보안 HTTP의 기본 포트)로 연결
* 연결이 되고 나면, 클라와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화
* 핸드셰이크가 완료되면 SSL 초기화가 완료되고, 클라는 요청 메시지를 보안 계층에 보낼 수 있다.

#### SSL 핸드셰이크
암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라와 서버는 SSL 핸드셰이크를 할 필요가 있다. 핸드셰이크에선 다음과 같은 일이 일어난다.
* 프로토콜 버전 번호 교환
* 양쪽이 알고 있는 암호 선택
* 양쪽의 신원을 인증
* 채널을 암호화하기 위한 임시 세션 키 생성

SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크를 주고 받는다.
* SSL 보안 매개변수 핸드셰이크 키를 만든다.
* 클라가 암호 후보들을 보내고 인증서를 요구
* 서버는 선택된 암호와 인증서를 보낸다.
* 클라가 비밀정보를 보내고, 클라와 서버는 키를 만든다.
* 클라와 서버는 서로에게 암호화를 시작한다고 말해준다.
* 그림 14-16

#### 서버 인증서
보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
* 서버에 그의 개인정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와준다.
* 서버 인증서는 여러 가지 정보를 보여주는, X.509 v3에서 파생된 인증서이다.
* 그림 14-17

#### 사이트 인증서 검사
SSL 자체는 인증서를 검증할 것을 요구하지 않지만, 최신 웹브라우저 대부분은 인증서에 대해 간단한 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.

넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹브라우저의 검사 기법의 기초를 구축했다.
* 날짜 검사
    * 시작 및 종료일을 검사해서 만료되었거나 활성화 되어있는지 확인
* 서명자 신뢰도 검사
    * 모든 인증서는 어떤 인증 기관(Certificate Authority, CA)에 의해 서명되어 있다.
    * 브라우저는 신뢰할 만한 서명 기관의 목록을 포함한 채로 배포
* 서명 검사
    * 서명 기관이 믿을만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사
* 사이트 신원 검사
    * 누군가 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사
    * 보통 단일 도메인 이름이 들어있지만, 몇몇 CA는 이름의 목록이나 서버 이름들에 대한 와일드카드 표현이 들어있는 인증서를 만든다.

#### 가상 호스팅과 인증서
가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
* 사용자 인증서의 이름과 정확히 맞지 않는 가상 호스팅을 사용하면 호스팅 제공자는 인증서의 호스트 명에 해당하는 주소로 리다이렉트한다.
* 그림 14-18

### 진짜 HTTPS 클라이언트
SSL은 복잡한 바이너리 프로토콜이다.
* 몇 가지 SSL 클라와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다.

#### OpenSSL
SSL과 TLS의 가장 인기 있는 오픈 소스 구현
* OpenSSL 프로젝트는, 강력한 다목적 암호법 라이브러리인 동시에 SSL과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 상용 수준의 툴킷

### 프락시를 통한 보안 트래픽 터널링
클라는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용한다.
* 클라가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다.
* 프락시가 HTTP 헤더를 읽을 수 없다면, 프락시는 요청을 어디로 보내야 하는지 알 수 없게 된다.

HTTPS가 프락시와도 잘 동작할 수 있게 하기 위해, 클라가 프락시에게 어디에 접속하려고 하는지 말해주는 방법을 약간 수정해야 한다.
* 인기 있는 기법 하나는 HTTPS SSL 터널링 프로토콜이다.
* 클라는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.
* 클라는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해준다.

HTTP는 CONNECT라 불리는 새로운 확장 메서드를 이용해서 평문으로 된 종단 정보를 전송하기 위해 사용한다.
* CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해준다.
* 그것이 완료되면, 클라와 서버 사이에서 데이터가 직접적으로 오갈 수 있게 해주는 터널을 만든다.
* CONNECT 메서드는, 안전한 원 서버의 호스트 명과 포트를 콜론으로 구분된 형태로 제공하는, 한 줄로 된 텍스트 명령이다.
* 핸드 셰이크가 성공했다면, SSL 데이터 전송이 시작된다.

```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/1.1N

<SSL로 암호화된 데이터…>
```

프락시는 요청을 평가하여 그것이 유효하고 사용자가 그러한 커넥션을 요청할 수 있도록 허가를 받았는지 확인한다.
* 만약 모든 것이 적법하다면 프락시는 목적지 서버로 연결하고 성공하면 200 Connection Established 응답을 클라에게 보낸다.

```
HTTP/1.0 200 Connection established
Proxy-agent: Netscape-Proxy/1.1
```