# 다이제스트 인증
기본 인증은 편리하고 유연하지만 전혀 안전하지 않다.
* 기본 보안을 안전하게 이용하는 유일한 방법은 SSL과 결합해서 사용하는 것이다.
* 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제로서 개발되었다.
* 다이제스트 인증은 널리 쓰이지는 않지만, 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용하다.

### 다이제스트 인증의 개선점
기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜로써 특징은 다음과 같다.
* 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
* 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
* 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
* 그 외 몇몇 잘 알려진 형태의 공격을 막는다.

가능한 가장 안전한 프로토콜은 아니다.
* 공개키 기반 메커니즘과 비교했을 때 그다지 강력한 인증 메커니즘을 제공하지 않는다.
* 안전한 HTTP 트랜잭션을 위한 요구사항들에는 전송 계층 보안(TLS)과 보안 HTTP(HTTPS)가 더 적합한 프로토콜
* 그러나 기본 인증보다 훨씬 강력하다.
* 아직 널리 쓰이고 있지 않다.

#### 비밀번호를 안전하게 지키기 위해 요약 사용하기
다이제스트 인증의 좌우명은 “절대로 비밀번호를 네트워크를 통해 보내지 않는다”이다.
* 비밀번호를 비가역적으로 뒤섞은 ‘지문(fingerprint)’ 혹은 요약(digest)’을 보낸다.
* 클라와 서버는 둘 다 비밀번호를 알고 있으므로, 클라가 보낸 요약이 알맞은지 검사할 수 있다.

#### 단방향 요약
요약은 ‘정보 본문의 압축’이다. 요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환
* 충돌이 날 수 있지만, 가능한 출력의 개수가 많기 때문에 무시해도 된다.
* 인기 있는 요약 함수 중 하나인 MD5는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다.
* 만약 비밀번호를 모른다면 요약을 추측하기 힘들고, 요약을 갖고 있다면 거의 무한개의 입력값들 중 그 요약을 생성하는 것을 찾아야 한다.
* 요약 함수는 보통 암호 체크섬(cryptographic checksums)으로 불리며, 단방향 해시 함수이거나 지문 함수(fingerprint function)이다.

#### 재전송 방지를 위한 난스(nonce) 사용
비밀번호를 모른다고 해도 요약을 가로채서 서버로 몇 번이고 재전송할 위험이 있다.
* 요약은 비밀번호 자체와 다름없다.
* 이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 난스라고 불리는 특별한, 그리고 자주 바뀌는(대략 1밀리초마다, 혹은 인증때마다) 증표를 건네준다.
    * 난스는 ‘임시의’ 혹은 ‘당분간’이라는 뜻
    * 컴퓨터 보안 측면을 고려해서, 난스의 계산식은 현재 시각을 포함한다.
* 난스를 비밀번호에 섞으면 난스가 바뀔때마다 요약도 바뀌게 만들어 재전송 공격을 막아준다.
* 난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라로 넘겨진다.

#### 다이제스트 인증 핸드셰이크
HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다.
* 기존 헤더에 몇몇 새 옵션이 추가
* 선택적인 헤더인 Authorization-Info가 새로 추가

다이제스트 인증의 세 단계 핸드셰이크
* 서버가 난스를 생성
* 서버가 영역(realm), 난스, 가능한 알고리즘 목록을 보낸다.
    * WWW-Authenticate(인증요구)
* 알고리즘을 선택하고, 응답 요약을 생성한다. 서버를 인증하길 원한다면 클라 난스를 생성
* 클라가 응답 요약, 알고리즘, 클라 난스을 보낸다.
    * Authorization(응답)
* 서버가 요약을 검증한다. rspauth 요약을 생성, 미리 다음번 난스를 생성
* 서버가 다음번 난스를 보낸다. 클라 rspauth 요약을 보낸다. 
    * Authentication-Info(정보)
* 클라가 rspauth 요약을 검증

### 요약 게산
다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약
* 일반적으로 요약 계산은 간단

#### 요약 알고리즘 입력 데이터
요약은 다음의 세 요소로부터 계산
* 단방향 해시 함수 H(d)와 요약 함수 KD(s, d).
    * s는 비밀(secret)을, d는 데이터(data)를 의미
* 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리.
    * A1이라 칭한다.
* 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리.
    * A2라 칭한다.
* A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

#### H(d)와 KD(s, d) 알고리즘
여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다.
* RFC 2617에서 제안된 두 알고리즘은 MD5와 MD5-sess(’sess’는 세션을 뜻한다)이며, 만약 알고리즘이 정해지지 않았다면 MD5가 기본값
* MD5와 MD5-sess 중 어느 것이 사용되더라도, H 함수는 데이터의 MD5를 계산하고, KD 요약 함수는 콜론으로 연결된 비밀 데이터와 일반 데이터의 MD5를 계산한다.
    * H(<데이터>) = MD5(<데이터>)
    * KD(<비밀>,<데이터>) = H(연결(<비밀>:<데이터>))

#### 보안 관련 데이터(A1)
사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.
* 메시지 자체가 아닌 비밀 정보와만 관련
* A1은 H, KD, A2와 마찬가지로 요약을 계산하기 위해 사용

MD5
* 모든 요청을 단방향 해시를 실행한다.
* A1 = <사용자>:<영역>:<비밀번호>

MD5-sess
* 해시를 계산한 결과 뒤에 현재 난스와 클라 난스(c난스)를 붙인 것
* CPU를 많이 사용하는 해시 계산은 처음 WWW-Authenticate 핸드셰이크를 할 때 단 한 번만 수행
* A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스>

#### 메시지 관련 데이터(A2)
URL, 요청 메서드, 메시지 엔티티 본문과 같은 메시지 자체의 정보
* A2는 위조를 방지하기 위해 사용
* A2는 H, KD, A1과 마찬가지로 요약을 계산하기 위해 사용
* RFC 2617은 선택된 보호 수준(quality of protection, qop)에 따른 A2의 두 가지 사용법을 정의
    * 첫 번째 방법은 HTTP 요청 메서드와 URL만 포함하는 것, 이것은 기본값이기도 한 qop=“auth”일 때 사용
        * <요청 메서드>:<uri 지시자 값>
    * 두 번째 방법은 메시지 무결성 검사를 제공하기 위해 메시지 엔티티 본문을 추가, qop=“auth-int”일 때 사용
        * <요청 메서드>:<uri 지시자 값>:H(<요청 엔티티 본문>)

#### 요약 알고리즘 전반
RFC 2617은 주어진 H, KD, A1, A2로 요약을 계산하는 두 가지 방법을 정의
* 예전 명세와 호환을 염두에 둔 것으로, qop 옵션이 빠졌을 때 사용
    * 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산
    * KD(H(A1), <난스>:H(A2))
        * 없어질 예정
    * MD5(MD5(A1):<난스>:MD5(A2))
* 현대적이면서 보다 선호되는 접근법으로 난스 횟수 집계 및 대칭 인증의 지원을 포함
    * qop가 ‘auth’일 때와 ‘auth-int’일 때 모두 사용
    * 난스 횟수, qop, c난스 데이터를 요약에 추가
    * KD(H(A1), <난스>:<nc>:<c난스>:<qop>:H(A2))
        * 이 방법을 선호
    * MD5(MD5(A1):<난스>:<nc>:<c난스>:<qop>:MD5(A2))

#### 다이제스트 인증 세션
어떤 보호 공간을 위한 WWW-Authenticate 인증요구에 대한 클라 응답은, 그 보호 공간에 대한 인증 세션을 시작하게 한다.
* ‘보호 공간’은 접근 중인 서버의 루트(canonical root)와 영역의 결합으로 정의

인증 세션은 클라가 보호 공간의 다른 서버로부터 또 다른 WWW-Authenticate 인증요구를 받을 때까지 지속
* 난스가 만료되면, 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고 오래된 Authorization 헤더 정보를 받아들이는 걸 택할 수 있다.
* 아니면 클라가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수 있다.
    * 이때 응답에 “stale=true”로 정의함으로써 사용자 이름과 비밀번호를 새로 입력할 필요 없이 새 난스 값으로 요청을 다시 보내라고 말할 수 있다.

#### 사전(preemptive) 인가
일반적인 인증에서는, 각 요청은 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로 한다.
* 만약 클라가 다음 난스가 무엇이 될지 미리 알고 있어서, 서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면, 이 요청/인증요구 사이클은 생략할 수 있다.
* 그림 13-4
    * 일반적인 요청/인증요구는 매번 요청/인증요구를 한다.
    * 사전 인가는 한번만 요청/인증요구를 하고 서버가 매번 다음 난스 정보를 넘겨줘서 클라는 바로 Authorization 헤더를 생성

사전 인가는 기본 인증에서는 사소하고 흔한 것
* 브라우저는 흔히 사용자 이름과 비밀번호 들에 대한 클라 측 데이터베이스를 관리
* 어떤 사이트에 인증하면, 브라우저는 흔히 그 URL에 대한 다음번 요청 때 올바른 Authorization 헤더를 전송

다이제스트 인증에서의 사전 인가는 약간 더 복잡하다.
* 왜냐면 난스 기술은 재전송 공격을 저지하기 위한 것이기 때문
* 서버는 임의의 난스를 생성하기 때문에, 인증요구를 받기 전에는 클라가 무엇이 올바른 Authorization 헤더인지 알 방법이 없다.
* 여러 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇 가지 방법을 제공
    * 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다.
    * 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용
    * 클라와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 생성

다음 난스 미리 생성하기
* 인증이 성공했을 때 200 OK와 함께 이 헤더를 미리 보낸다.
    * Authentication-Info: nextnonce=“<난스 값>"
* 주어진 난스로 클라는 Authorization 헤더를 미리 만들어 둘 수 있다.
* 요청/인증요구 사이클에서 벗어날 수 있다(트랜잭션 속도 향상).
* 반면 같은 서버에 다중 요청을 파이프라이닝하는 능력은 실질적으로 쓸모가 없어진다.
    * 다음 요청을 보내기 전에 반드시 다음 난스 값을 받아야 하기 때문
    * 파이프라이닝은 회전 지연(latency) 회피를 위한 기반 기술이기 때문에 성능상 불이익은 더 커진다.

제한된 난스 재사용
* 또 다른 방법은 난스를 제한적으로 재사용 하는 것.
    * 예를 들어 한 난사를 다섯 번 혹은 10초간 재사용하도록 허락
* 클라는 난스를 미리 알 수 있으므로 자유롭게 Authorization 헤더와 함께 요청을 파이프라이닝 할 수 있다.
* 난스가 만료되면 서버는 401 Unauthorizaed 인증요구를 보낼 것이다.
* 이 때 WWW-Aithenticate: stale=true 지시어는 다음과 같이 설정
WWW-Authenticate: Digest
    realm=“<영역 값>”
    nonce=“<난스 값>”
    stal=true

난스를 재사용하면 공격자의 재전송 공격이 쉬워지므로 보안성이 감소
* 트레이드 오프가 있다.

추가적으로, 카운터 증가나 IP 주소 검사와 같이 재전송 공격을 더 어렵게 만들 수 있는 기능들을 채택할 수도 있다.
* 이러한 기법은 공격을 불편하게 만들 수는 있지만 취약점을 제거할 수는 없다.

동기화된 난스 생성
* 제3자가 쉽게 예측할 수 엇는 공우된 비밀키에 기반함녀서 클라와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능
* 이 알고리즘은 다이제스트 인증 명세의 범위를 넘어서는 것이다.

#### 난스 선택
난스의 내용은 불투명하고 구현 의존적이다. 그러나성능 수준, 보안, 편의성은 현명한 선택에 달려있다.
* RFC 2617은 다음과 같은 가상의 난스 공식을 제안
BASE64(타임스탬프 H(타임스탬프”:” ETag “:” 개인 키))
* 타임스탬프는 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값
* ETag는 요청된 엔티티에 대한 ETag 헤더 값
* 개인 키는 서버만이 알고 있는 값

서버는 클라 인증 헤더를 받은 뒤, 위의 공식에서 해시 부분을 재계산 해보고 클라 인증 헤더의 난스와 일치하지 않거나 타임스탬프가 오래되었다면 요청을 거절
* 이 방법에서 서버는 난스의 유효 기간을 제한할 수 있다.

ETag를 포함하면 갱신된 리소스에 대한 재요청을 방지한다. 🤔
* 클라 IP 주소를 난스에 포함하는 것은, 서버에게 같은 클라가 원래 받았던 난스를 재사용하는 것을 제한하는 능력을 주는 것처럼 보일 수 있지만, 한 사용자가 여러 프락시를 거쳐 요청할 수도 있기 때문에, 이는 프락시 팜을 망가뜨리게 될 수 있다. 또, IP를 속이는 것은 어렵지 않다.

재전송 공격을 방지하기 위해, 어떤 구현은 이전에 사용된 난스나 요약을 받아들이지 않도록 결정할 수 있다.
* 혹은 POST나 PUT 요청을 위해 일회성 난스나 요약을 사용하고, GET 요청을 위해 타임스탬프를 사용할 수도 있다.
    * 메서드에 따라 다르게 사용할 수 있는듯

#### 상호 인증
클라가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다.
* 서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록, 클라 난스 값을 제공함으로써 가능
* 이후 서버는 Authentication-Info 헤더를 통해 요약을 클라에게 전달
* 응답 요약은 메시지 본문 정보(A2)가 다르다는 것만 제외하면 요쳥 요약과 같은 방법을로 계산할 수 있다.
* 표13-6, 표13-7

### 보호 수준(Quality of Protectio) 향상
qop 필드는 요약 헤더의 세가지 헤더 모두에 존재할 수 있다.
* WWW-Authenticate
* Authorization
* Authentication-Info

Qop 필드는 클라와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.
* 서버가 qop 옵션 목록을 주면 클라는 선택해서 서버에게 돌려준다.
* qop 사용이 선택사항이지만 하위 호환성을 유지하기 위해서이기 때문에 모든 현대적인 요약 구현은 qop 옵션을 지원을 해야한다.
* 기본적으로 두 가지 초기 보호수준 값을 정의
    * 인증을 의미하는 “auth"
    * 인증 및 메시지 무결성 보호를 의미하는 “auth-int"

#### 메시지 무결성 보호
무결성 보호가 적용되었을 때 (qop=“auth-int”) 계산되는 H(엔티티 본문)는, 메시지 본문의 해시가 엔티티 본문의 해시다.

#### 다이제스트 인증 헤더
기본, 다이제스트 인증 프로토콜 양쪽 모두 WWW-Authenticate 인증요구와 Authorization 인가 응답을 포함
* 다이제스트 인증은 여기에 선택적인 Authentication-Info 헤더를 추가
    * 3단계 핸드셰이크를 완성하고 다음번 사용할 난스를 전달하기 위해 인증 성공 후에 전송
* 표13-8

### 실제 상황에 대한 고려
다이제스트 인증 작업을 할 때 고려해야 할 것이 몇 가지 있다.

#### 다중 인증요구
서버는 한 리소스에 대해 여러 인증을 요구할 수 있다.
* 클라의 능력을 모른다면, 서버는 기본 및 다이제스트 인증요구를 모두 보낼 것이다.
* 클라는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다.

### 오류 처리
다이제스트 인증에서, 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져 있는 경우 알맞은 응답은 400 Bad Request이다.
* 요청의 요약이 맞지 않으면, 로그인이 실패했음을 기록해두는 것이 좋다.
    * 반복된 실패는 공격을 시도하고 있음을 의미
* 인증 서버는 반드시 ‘uri’ 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야 한다.
    * 다르다면 공격의 징후일 수 있음으로 400 Bad Request
* 이 필드와 요청 URL과의 중복된 정보는 중간의 프락시가 클라 요청줄을 변조했을 가능성에 대처할 수 있게 해준다.
    * 변형된 요청의 요약(의미는 같음)을 계산한 결과는 클라가 계산한 요약과 다르다.

### 보호 공간(Protection Space)
영역 값은, 접근한 서버의 루트 URL과 결합되어, 보호 공간을 정의한다.
* 영역 값은 일반적으로 원 서버에 의해 할당되는 문자열이며 인증 제도에 추가적인 의미를 더한다.
* 인가 제도는 같지만 영역은 다른 다중 인증요구가 있을 수 있음에 주의

보호 공간은 어떤 자격이 자동으로 적용되는 영역을 결정한다.
* 이전 요청이 인가되면, 같은 자격은 인증 제도, 매개변수, 사용자 설정 중 한 가지 이상에 의해 정해진 시간 동안 재사용 될 것이다.
* 인증 제도에 별달리 정의된 것이 없다면, 하나의 보호 공간은 서버 밖으로 확장될 수 없다.

보호 공간의 구체적인 계산은 인증 메커니즘에 달려있다.
* 기본 인증에서, 클라는 요청 URI와 그 하위의 모든 경로는 같은 보호 공간에 있는 것으로 가정
    * 클라는 이 공간에서 서버로부터의 또 다른 인증 요구를 기다리지 않고 미리 리소스에 대한 인가를 받을 수 있음
* 다이제스트 인증에서, 인증요구의 WWW-Authenticate: domain 필드는 보호 공간을 보다 엄밀하게 정의
    * domain 필드는 URI의 공백으로 분리된 목록
    * 이 domain 목록의 모든 URI와 논리적으로 그 하위에 위치한 모든 URI는 같은 보호 공간에 있는 것으로 가정
    * 만약 domain 필드가 없거나 빈 값이라면, 인증을 요구하는 서버의 모든 URI는 그 보호 공간에 있는 것이다.

### URI 다시 쓰기
프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 한다.
* 호스트 명은 정규화되거나 IP 주소로 대체
* 문자들은 “%” escape 형식으로 대체
* 리소스에 영향을 주지 않는, 타입에 대한 속성이 URI의 끝, 혹은 중간에 삽입될 수 있다.

프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로, 다이제스트 인증은 이러한 변경에 의해 실패할 수 있다.

#### 캐시
어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안됨
* must-revalidate
* public

### 보안에 대한 고려사항
RFC 2617은 HTTP 인증 제도에 내재된 보안 위협의 일부를 정리했다.

#### 헤더 부당 변경
양 종단 암호화나 헤더에 대한 디지털 서명이 필요할 것이다.
* 양쪽의 조합이면 더 좋다.
* 다이제스트 인증은 조작할 수 없는 인증 제도를 제공하는 것에 초점
* 반드시 그 보호를 데이터에까지 확장하는 건 아니다.
* 보호 수준에 대한 정보는 WWW-Authenticate와 Authorization 헤더에만 담겨있다.

### 재전송 공격
재전송 공격은 GET 요청에 대한 이슈이긴 하지만, POST와 PUT 요청에 대해서도 잘 동작하는 예방책을 가지고 있어야 한다.
* 서버가 재전송된 자격을 승인했다는 것은, 같은 난스 값을 반복해서 사용한 것
* 재전송을 피하는 방법은 매 트랜잰션마다 유일한 난스 값을 사용하는 것

### 다중 인증 메커니즘
서버가 다중 인증 제도를 지원할 때 WWW-Authenticate 헤더를 통해 선택지를 제공
* 클라가 가장 강력한 인증 메커니즘을 선택할 의무는 아니기 때문에, 결국 인증의 강도는 선택지 중 가장 약한 것과 같다.
* 이 문제를 피하기 위해 클라가 언제나 강력한 인증제도를 선택하는 것
* 현실적으로 불가능하다면 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용
    * 모든 클라가 해당 인증 제도를 지원할 수 있다고 알려진 경우에만 가능(사내 네트워크)

#### 사전(dictionary) 공격
사전 공격은 전형적인 비밀번호 추측 공격
* 만약 사용자는 단순 비밀번호, 서버는 단순 난스를 사용한다면 해당 값들을 찾아내 확률이 꽤 있다.
* 비밀번호 만료 정책이 없고, 충분한 시간이 있으며, 비밀번호를 크래킹할 1회 비용을 치를 수 있다면 실질적인 타격을 입히기에 충분한 양의 비밀번호를 쉽게 수집 할 수 있다.
* 이 문제를 해결할 좋은 방법은 크래킹하기 어렵도록 상대적으로 복잡한 비밀번호, 괜찮은 비밀번호 만료 정책 외에는 실질적으로 없다.

#### 악의적인 프락시와 중간자 공격(Man-in-the-Middle Attack)
많은 인터넷 트래픽이 오늘날 한 프락시에서 다른 프락시로 이동한다.
* 이들 프락시 중 하나가 악의적이거나 보안이 허술하면 클라는 중간자 공격에 취약한 상태가 될 가능성이 있다.
* 엿듣기 공격일 수 있고, 인증 제도 선택지를 모두 제거하고 기본 인증으로 대체하는 것일 수 있다.
* 프락시의 신뢰도에 흠집을 낼 수 있는 것 중 하나는 자신의 확장 인터페이스
    * 다만 데이터 센터의 보안과 프락시 자체가 제공하는 보안은 악의적인 플러그인을 통한 중간자 공격 가능성을 매우 희박하게 한다.
* 그냥 SSL을 사용하는 것밖에 이 문제를 해결할 수 있는 방법은 없다.

#### 선택 평문 공격
다이제스트 인증을 사용하는 클라는 응답을 생성하기 위해 서버가 제공한 난스를 사용
* 악의적인 프락시가 트래픽 중간에 끼어든다면, 어렵지 않게 클라가 응답 계산을 하기 위한 난스를 제공 할 수 있다.
* 응답을 계산하기 위해 알려진 키를 사용하는 것은 응답의 암호 해독을 쉽게 한다.
* 이것을 선택 평문이라 하고 몇 가지 변종이 있다.

미리 계산된 사전 공격
* 사전 공격과 선택 평문 공격의 조합
* 먼저 공격 서버는 미리 결정된 난스와 자주 쓰이는 비밀번호들로 응답의 집합을 생성하고 사전을 만든다.
* 트래픽을 차단하고 클라로 미리 결정된 난스를 전송
* 클라로 응답을 받을 때, 대응되는 항목이 사전에 있으면 비밀번호를 손에 넣은 것

자동화된 무차별 대입 공격
* 미리 계산된 요약을 맞춰보려는 대신 가능한 모든 비밀번호를 열거하여 공격

일반적으로 이런 공격으로 인한 위협은 쉽게 방어할 수 있다.
* 클라가 서버에서 제공된(공격에 취햑할 수 있는) 난스 대신 선택적인 c난스 지시자를 사용하여 응답을 생성
* 강력한 비밀번호를 강제하는 것

#### 비밀번호 저장
다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것과 비교한다.
* 다이제스트 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 즉각 공격자에게 노출
* 암호 해독 과정은 필요 없다.

이 문제를 완화하는 방법
* 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다 생각하고 안전하게 보호
* 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되도 특정 영역으로 국소화
    * 호스트와 도메인을 포함한 완전한 영역 이름은 이 요구를 만족

다이제스트 인증이 기본 인증에 비해 훨씬 탄탄하고 안전하지만 콘텐츠에 대한 보안 측면은 어떠한 보호도 제공하지 못한다.
* 진정한 보안 트랜잭션은 오로지 SSL을 통해서만 가능하다.