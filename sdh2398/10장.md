# HTTP/2.0

### HTTP/2.0의 등장 배경
HTTP/1.0의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.
* 성능을 어느 정도 희생시키지 않을 수 없었다.
* 요청을 하나 보내고 그에 대한 응답을 받는 교환 방식은 단순하지만 심각한 회전 지연(latency)을 피할 수 없었다.
* 병렬 커넥션이나 파이프 라인 커넥션이 도입되었지만 성능 개선의 근본적인 해결책은 되지 못했다.

HTTP/1.1 명세가 발표된 지 십수년 동안, 이 성능 문제를 해결하려고 많은 이들이 노력했다.
* 구글은 웹을 더 빠르게 하겠다는 목표 아래 SPDY(‘스피디’) 프로토콜을 내놓았다.
    * 기존의 HTTP에 속도를 개선하기 위한 여러 기능을 추가
    * 헤더를 압축하여 대역폭을 절약
    * 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능
    * 클라가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능을 갖춤

HTTP 작업 그룹은 SPDY을 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정하였음을 밝혔다.
* SPDY의 초안을 그대로 가져와서 HTTP/2.0 초안을 만들기 시작했다.
* 여덟 번째 초안까지 크게 변경된 점이라면 헤더를 압축할 때 더 이상 deflate 알고리즘을 사용하지 않게 되었다는 것

### 개요
HTTP/2.0은 서버와 클라 사이의 TCP 커넥션 위에서 동작
* TCP 커넥션을 초기화하는 것은 클라

HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담긴다.
* 이 때 HTTP 헤더는 압축되어 담긴다.
* 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다.
* 한 개의 스트림이 한 쌍의 요청과 응답을 처리
* 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어 질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능
* 이들 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공

HTTP/2.0은 기존과는 다른 새로운 상호작용 모델인 서버 푸시를 도입
* 서버는 클라에게 필요하다고 생각하는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라에게 보내줄 수 있다.

기존 웹 애플리케이션들과 호환성을 최대한 유지하기 위해, HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지
* 메시지를 표현하는 문법은 변경
    * Content-Length 헤더의 이름은 ‘:content-length'
    * 상태줄을 통해 표현하던 404 Not Found는 ‘404’값을 갖고 있는 ‘:status’ 헤더

### HTTP/1.1과의 차이점

#### 프레임
HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송
* 모든 프레임은 8바이트 크기의 헤더로 시작
* 그림 10.1

#### 스트림과 멀티플렉싱
스트림은 HTTP/2.0 커넥션을 통해 클라와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
* 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다.
* 클라는 스트림을 통해 요청을 보내고, 서버는 같은 스트림을 통해 응답을 보낸다. 그러고 나면 스트림이 닫히게 된다.
* HTTP/1.1에서는 한 TCP 커넥션 요청이 보내졌을 때, 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있다.
* 회전 지연을 줄이기 위해 여러 개의 커넥션을 만들어 동시에 보내지만, 무한정 만들 수는 없으므로 회전 지연이 늘어나는 것을 피하기 어렵다.
* 파이프라인 커넥션을 통해 이것을 피할 수는 있으나 그다지 널리 구현되지는 않음

HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.
* 스트림은 우선순위도 가질 수 있다.
    * 우선순위를 따라는 것은 의무사항이 아니기 때문에, 요청이 우선순위대로 처리된다는 보장은 없다.

모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다.
* 클라에 의해 초기화 되었다면 홀수, 서버라면 짝수
* 새로 만들어지는 스트림의 식별자는 이전보다 커야 한다.
    * 이 규칙을 어기면 에러를 반환
* 서버와 클라는 스트림을 상대방과 협상 없이 일방적으로 만든다.
    * 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 된다.
* 커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 하는데, 이 때는 커넥션을 다시 맺으면 된다.

#### 헤더 압축
HTTP/1,1에서 헤더는 아무런 압축 없이 그대로 전송되었다.
* 예전에는 요청이 많지 않아 문제가 되지 않았지만, 요즘에는 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼친다.

이를 개선하기 위해 HTTP/2.0은 HTTP 메시지의 헤더를 압축하여 전송
* SPDY 프로토콜에서는 deflate 알고리즘으로 압축했지만 보안 문제 때문에 HPACK 명세에 따라 압축
* 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 ‘헤더 블록 조각’들로 쪼개져서 전송
* 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원

HPACK은 헤더를 압축하고 해제할 때 ‘압축 콘텍스트(compression context)’를 사용
* 오동작하지 않으려면 항상 올바른 압축 콘텍스트를 유지해야 한다.
* 수신한 헤더의 압축을 풀면 이에 영향을 받아 바뀐다.
* 송신 측은 수신 측이 헤더의 압축을 풀었으며 그에 따라 압축 콘텍스트가 변경되엇다고 가정
* 수신 측은 어떤 경우(헤더를 쓰지않고 버리는 경우)에도 반드시 압축 해제를 수행해야 한다.
* 압축 해제를 할 수 없으면 COMPRESSION_ERROR와 함께 커넥션을 끊어야 한다.

#### 서버 푸시
HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
* 서버가 클라에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유리
* 이는 클라가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하게 되는 트래픽과 회전 지연을 줄여준다.
* 리소스를 푸시하려는 서버는 먼저 클라에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내 미리 알려주어야 한다.
    * 클라는 해당 스트림은 클라 입장에서 ‘예약됨' 상태가 된다.
    * 클라는 RST_STREAM 프레임을 보내어 푸시를 거절 할 수 있고, 그 즉시 닫힌다.
* 스트림이 닫히기 전까지 클라는 서버가 푸시하려고 하는 리소스를 요청해서는 안된다.

서버 푸시를 사용할 때는 다음에 주의해야 한다.
* 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 클라에게 전달 하지 않을 수도 있고 추가 리소스를 전달할 수도 있다.
* 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.
* 푸시할 리소스는 클라가 명시적으로 보낸 요청과 연관된 것이어야 한다.
    * 서버가 보내는 PUSH_PROMISE 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다.
* 클라는 반드시 서버가 푸시한 리소스를 동일 출처 정책(Same-origin poliy)에 다라 검사해야 한다.
    * 예를 들어, ‘example.org’로의 HTTP/2.0 커넥션은 ‘www.example.org’로부터의 푸시 응답을 허용하지 않는다.
* 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH을 0으로 설정하면 된다.

### 알려진 보안 이슈

#### 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)
HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1로 변환할 때 메시지의 의미가 변질될 가능성이 있다.
* 1.1과는 달리 2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다.
* 이는 2.0이 헤더 필드로 어떤 문자열(줄바꿈 문자조차 허용)이든 사용할 수 있게 해준다.
* 정상적인 2.0 요청이나 응답이, 불법적이거나 위조된 1.1 메시지로 번역되는 것을 유발할 수 있다.
* 다행히 1.1 메시지를 2.0 메시지로 번역하는 과정에서는 이런 문제가 발생하지 않는다.

#### 긴 커넥션 유지로 인한 개인정보 누출 유려
HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라와 서버 사이의 커넥션을 오래 유지하는 것을 염두해 두고 있다.
* 개인정보 유출에 악용될 가능성이 있다.
* 브라우저를 사용할 때, 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아 낼 수 있다.
* HTTP가 현재 갖고 있는 문제이기도 하지만, 짧게 유지되는 커넥션에서는 위험이 적다.

































