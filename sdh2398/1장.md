# 1장 HTTP 개관

전 세계의 웹브라우저, 서버, 웹 애플리케이션은 모두 HTTP를 통해 대화한다.
* HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용
* 사용자는 인터넷에서 얻은 정보가 손상된 게 아닌지 염려하지 않아도 된다.

### 리소스
웹 서버는 웹 리소스를 관리하고 제공한다.
* 가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일이다.
* 요청에 따라 콘텐츠를 생산하는 동적 콘텐츠 리소스도 있다.

HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙인다.
* MIME(Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)
* 원래 각기 다른 전자메일 시스템 사이에서 메세지가 오갈 때 겪는 문제점을 해결하기 위해 설계
* 웹 브라우저는 서버로부터 객체를 받을 때 MIME 타입을 통해 다룰 수 있는 객체인지 확인한다.
* MIME 타입은 사선(/)으로 구분된 주 타입과 부 탕비으로 이루어진 문자열 레빌이다.
    * HTML - text/html
    * Plain ASCII - text/plain
    * JPEG - image/jpeg
    * GIF - image/gif

웹 서버 리소스는 각자 이름을 갖고 있다.
* 서버 리소스 이름은 통합 자원 식별자(uniform resource identifier), 혹은 URI로 불린다.
* 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.

URI에는 두 가지가 있다.

URL
* 통합 자원 지시자(uniform resource locator)
* 리소스 식별자의 가장 흔한 형태
* 특정 서버의 한 리소스에 대한 구체적인 위치를 서술
* URL은 세 부분으로 이루어진 표준 포맷을 따른다.
    * 첫 번째 부분은 스킴(schme), 리소스에 접근하기 위해 사용되는 프로토콜 ex) http://
    * 두 번째 부분은 서버의 인터넷 주소 ex) www.joes-hardward.com
    * 마지막은 웹 서버의 리소스 ex) /specials/saw-blade.gif
* 오늘날 대부분의 URI는 URL이다.

URN
* 유니폼 리소스 이름(uniform resource name)
* 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할 ex) urn:ietf:rfc:2141
* 독립적인 URN은 리소스를 여기저기 옮기더라도 문제없이 동작
* URN은 여전히 실험 중인 상태고 앚기 널리 채택되지 않았다.

### 트랜잭션
HTTP 트랜잭션은 요청 명령과 응답 결과로 구성되어 있다.
* HTTP 메세지라고 불리는 정형화된 데이터 덩어리를 이용해 이루어짐

메서드
* HTTP는 여러 가지 종류의 요청 명령을 자원한다.
* 모든 HTTP 요청 메세지는 한 개의 메서드를 갖는다.

상태 코드
* 모든 HTTP 응답 메세지는 세 자리 숫자인 상태 코드와 함께 반환
* 숫자 상태 코드에 텍스트로 된 사유 구절도 함께 보낸다.
    * 단지 설명만을 위해서 포함된 것일 뿐 실제로는 상태 코드만 사용한다.

메세지
* HTTP 메시지는 단순한 줄 단위의 문자열이다.
* 이진 형식이 아닌 일반 텍스트이다.
* HTTP는 세 부분으로 이루어진다.
    * 시작줄
        *  메세지의 첫 줄
    * 헤더 
        * 시작줄 다음에 0개 이상의 헤더 필드
        * 콜론으로 구분되어 이름과 값이 추가된다.
        * 헤더는 빈 줄로 끝난다.
    * 본문
        * 빈 줄 다음에 어떤 종류의 데이터든 들어갈 수 있다.

### TCP 커넥션
HTTP는 애플리케이션 계층 프로토콜이다.
* 네트워크 통신은 TCP/IP에게 맡긴다.
    * 오류 없는 데이터 전송
    * 순서에 맞는 전달
    * 조각나지 않는 데이터 스트림

HTTP 클라이언트가 서버에 메세지를 전송하기 전에 IP(Internet protocol) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다.
* 서버 컴퓨터에 대한 IP주소
* 서버에서 실행 중인 프로그램이 사용 중인 포트 번호
* URL로 알아낼 수 있다.

HTTP가 TCP/IP를 이용해서 통신이 이루어지는 순서
* 서버의 URL에서 호스트 명을 추출
* DNS를 통해 서버의 호스트 명을 IP로 변환
* URL에서 포트번호가 있다면(없다면 기본값 80) 추출
* 웹 서버와 TCP 커넥션을 맺는다.
* 서버에 HTTP 요청을 보낸다.
* 서버는 HTTP 응답을 돌려준다.
* 커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

### 프로토콜 버전
오늘날 쓰이고 있는 HTTP 프로토콜은 버전이 여러 가지다.

HTTP/0.9
* 심각한 디자인 결함이 다수 있고 구식 클라이언트하고만 같이 사용할 수 있다.
* 오직 GET 메서드만 지원
* 멀티미디어 콘텐츠 MIME 타입, HTTP 헤더, 버전 번호는 지원하지 않는다.
* 간단한 HTML 객체를 받아오기 위해 만들어 진 것

HTTP/1.0
* 처음으로 널리 쓰이기 시작한 HTTP 버전
* 버전 번호, HTTP 헤더, 추가 메서드 ,멀티미디어 객체 처리를 추가

HTTP/1.0+
* WWW이 급격히 팽창하고 성공하면서 HTTP에 기능을 추가해갔다.
* 많은 기능이 공식적이진 않지만 사실상의 표준으로 추가되었다.
    * “keep-alive” 커넥션
    * 가상 호스팅 지원
    * 프락시 연결 지원
* 이 규격 외에 확장된 HTTP 버전을 흔히 HTTP/1.0+라고 부른다.

HTTP/1.1
* HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중
* 더 복잡해진 웹 애플리케이션과 배포를 지원
* 현재의 HTTP 버전

HTTP/2.0
* HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행중인 프로토콜


### 웹의 구성 요소
인터넷과 상호작용할 수 있는 웹 애플리케이션은 많다.

프락시
* 클라이언트와 서버 사이에 위치한 HTTP 중개자
* 주로 보안을 위해 사용
* 요청과 응답을 필터링한다.

캐시
* 많이 찾는 웹 페이지를 클라이언트 가까이에 보관하는 HTTP 창고
* 특별한 종류의 HTTP 프락시 서버

게이트웨이
* 다른 애플리케이션과 연결된 특별한 웹 서버
* 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용
* 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다.
* 클라는 자신이 게이트웨이와 통신하고 있음을 알아채지 못할 것이다.

터널
* 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
* 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용
    * 예로 암호화된 SSL 트래픽을 HTTP 커넥션으로 연결해주는 것

에이전트
* 자동화된 HTTP 요청을 만드는 준지능적(semi-intelligent) 웹 클라이언트
    * 웹 브라우저
    * 웹 페이지를 수집해 검색엔진 데이터베이스에 저장하는 스파이더