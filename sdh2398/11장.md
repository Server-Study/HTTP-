# 클라이언트 식별과 쿠키

웹 서버는 서로 다른 수천 개의 클라와 동시에 통신한다.
* 익명의 클라로부터 받는 모든 요청을 처리할 수 있어야 함
* 서버와 통신하고 있는 클라를 추적해야 할 수 있음

### 개별 접촉
HTTP는 익명으로 사용하며 상태가 없고(stateless) 요청과 응답으로 통신하는 프로토콜
* 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.
* 현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어 한다.

Amazon은 여러 가지 방식으로 사이트를 개인화시켜 제공
* 개별 인사
    * 사용자에 특화된 페이지를 만듦
* 사용자 맞춤 추천
* 저장된 사용자 정보
    * 복잡한 주소와 신용카드 정보를 디비에 저장하는 온라인상점도 있다.
* 세션 추적

HTTP 자체에 식별 관련 기능이 풍부하지 않아서, 초기 웹 사이트 설계자들은 사용자를 식별하는 그들만의 기술을 개발했다.
* 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
* IP 주소로 사용자를 식별
* 로그인 인증을 통한 사용자 식별
* URL에 식별자를 포함하는 기술인 뚱뚱한(fat) URL
* 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

### HTTP 헤더
From 헤더는 사용자의 이메일 주소를 포함
* From 헤더로 사용자를 식별할 수 있다.
* 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From 헤더를 보내는 브라우저는 많지 않다.
* 실제로 로봇이나 스파이더는 웹 마스터가 항의 메일을 보낼 수 있도록 From 헤더에 이메일 주소를 기술한다.

User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 어떤 경우에는 운영체제에 대한 정보까지 포함하여 알려준다.
* 특정 브라우저의 속성에 맞추어 콘텐츠를 최적화하는 데 유용하다.
* 특정 사용자를 식별하는 데는 큰 도움을 주지 않는다.

Referer 헤더는 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다.
* Referer 자체만으로는 사용자를 식별할 수 없다.
* 이 헤더를 통해 사용자의 웹 사용 행태나 사용자의 취향을 더 잘 파악할 수 있다.

### 클라이언트 IP 주소
사용자 식별에 클라 IP 주소를 사용하는 방식은, IP 주소가 좀처럼(혹은 절대) 바뀌지 않고, 웹 서버가 요청마다 클라의 IP를 알 수 있다면 문제없이 동작한다.
* HTTP 헤더에는 없지만, 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소는 알아낼 수 있다.

클라 IP 주소로 사용자를 식별하는 방식은 다음과 같은 약점이 있다.
* 만약 여러명이 같은 컴퓨터를 사용한다면 식별할 수 없다.
* 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP주소를 할당한다.
* 보안을 강화하고 부족한 주소들을 관리하려고 많은 사용자가 네트워크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용한다.
    * 클라의 실제 IP 주소를 방화벽 뒤로 숨기고, 클라의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP 주소로 변환
* 보통, HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다.
    * 웹 서버는 클라 IP 주소 대신 프락시 서버의 IP 주소를 본다.

아직 세션 간에 사용자를 추적하려고 클라 IP 주소를 사용하는 웹 사이트가 있다.
* 보안 기능으로 특정 IP 주소에만 문서를 전달하기도 한다.
* 인트라넷 같이 제한된 영역에서는 적절

### 사용자 로그인
사용자 이름과 비밀번호로 인증(로그인)할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
* 한 번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내서 로그인 정보를 확인할 수 있다.
* 사용자의 식별정보를 알지 못하면 401 Login Required 응답 코드와 WWW-Authenticate 헤더를 반환하여 로그인 요청
* 로그인 후로는 해당 사용자의 식별정보 토큰을 Authorization 헤더에 담아 서버로 전송

### 뚱뚱한 URL
사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적한다.
* URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다.
* URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.

여러가지 심각한 문제가 발생할 수 있다.
* 못생긴 URL
* 공유하지 못하는 URL
    * 해당 주소를 공유하면 개인 정보를 공유하게 된다.
* 캐시를 할 수 없음
* 서버 부하 가중
    * 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다.
* 이탈
    * 이탈하게 되면, 지금까지 진척상황들이 초기화되서 처음부터 다시 해야 한다.
* 세션 간 지속성의 부재
    * 로그아웃하면 모든 정보를 잃는다.

### 쿠키
사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.
* 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

#### 쿠키의 타입
크게 세션 쿠키와 지속 쿠키 두 가지 타입으로 나눌 수 있다.
* 세션 쿠키
    * 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키
    * 사용자가 브라우저를 닫으면 삭제된다.
* 지속 쿠키
    * 지속 쿠키는 삭제되지 않고 더 길게 유지될 수 있다.
    * 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다.
    * 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.
* 둘의 다른 점은 파기되는 시점 뿐


#### 쿠키는 어떻게 동작하는가
* 처음에 사용자가 웹 사이트를 방문하면 웹 서버는 사용자에 대해 아무것도 모른다.
* 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당
    * 임의의 이름=값 형태의 리스트를 가지고, Set-Cookie 혹은 Set-Cookie2 같은 응답 헤더에 기술되어 사용자에게 전달
* 쿠키는 어떤 정보든 포함할 수 있지만, 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다.
    * 서버는 할당한 쿠키 값으로 디비에서 사용자의 정보를 찾는데 사용할 수 있다.
    * 브라우저는 서버로 온 쿠키 콘텐츠를 브라우저 쿠키 디비에 저장한다.
* 사용자가 미래에 같은 사이트를 방문하면, 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 기술해 전송한다.

#### 쿠키 상자: 클라이언트 측 상태
쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것
* 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 ‘클라 측 상태’라고 한다.

#### 사이트마다 각기 다른 쿠키들
브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 쿠키 전부를 모든 사이트에 보내지는 않는다.
* 쿠키를 모두 전달하면 성능이 크게 저하
* 대부분 해당 서버에 특화된 이름/값 쌍을 포함하고 있어서, 다른 서버에서는 무의미한 값이다.
* 잠재적인 개인정보 문제를 일으킬 것이다.

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 제공한다.
* 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.
    * Set-cookie: user=“mary17”; domain=“airtravelbargains.com"

웹 사이트 일부에만 쿠키를 적용할 수도 있다.
* URL 경로의 앞부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달
    * Set-cookie: pref=pompact; domain=“airtravelbargains.com”; apth=/autos/

#### 쿠키 구성요소
현재 사용되는 쿠키 명세에는 Version0('넷스케이프 쿠키'), Version1(‘RFC 2965’)가 있다.
* Version1은 Version0의 확장으로 널리 쓰이지는 않는다.
* RFC 2965는 2011년에 나온 RFC 6265에 의해 폐기되어 현재 사용되지 않는 HISTORIC 상태

#### Version0(넷스케이프) 쿠키
최초의 쿠키 명세는 넷스케이프가 정의했다.
* Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는데 필요한 필드를 정의
* 표 11-3
```
Set-Cookie : name=value [; expires=date] [; path=path] [; domain=domain] [; secure]

Cookie : name1=value1 [; name2=value2] ...
```

#### Version1 (RFC 2965) 쿠키
Version0과 호환되며, 넷스케이프 표준보다 좀 더 복잡하고, 모든 브라우저나 서버가 완전히 지원하지 않는다.
* 폐기되어서 더 이상 지원되지 않음

#### 쿠키와 세션 추적
쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.
* 전자상거래 웹 사이트는 쇼핑카트를 유지하려 세션 쿠키를 사용한다.
* http://www.amazon.com 을 브라우저에 입력하면, 일련의 리다이렉트, URL 리다이렉트, 쿠키 설정을 통해 서버가 식별 정보를 첨부하기 위한 연속적인 트랜잭션을 시작

#### 쿠키와 캐싱
쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.
* 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수도 있다.

쿠키와 캐싱에 관련된 규칙은 정리가 잘 되어 있지 않다. 다음은 캐시를 다루는 기본 원칙에 대한 안내이다.
* 캐시되지 말아야 할 문서가 있다면 표시하라
    * Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 Cache-Control: no-cache=“Set-Cookie”를 기술해서 명확히 표시
    * 캐시를 해도 되는 문서에 Cache-Control: public을 사용하면 웹의 대역폭을 더 절약시켜준다.
        * public은 공유 캐시(또는 중개 서버)에 저장해도 된다는 뜻이고, private이면 브라우저같은 특정 사용자 환경에서만 저장하라는 뜻
* Set-Cookie 헤더를 캐시 하는 것에 유의하라
    * 응답이 Set-Cookie 헤더를 가지고 있으면, 본문은 캐시할 수 있지만, Set-Cookie를 캐시하는것은 주의를 기울여야 한다.
    * 어떤 캐시는 응답을 저장하기 전에 Set-Cookie 헤더를 제거하기 때문에, 그 캐시를 받는 클라는 Set-Cookie 헤더 정보가 없어서 문제가 발생할 수 있다.
    * 모든 요청마다 원 서버와 재검사 시켜 클라로 가는 응답에 Set-Cookie 헤더 값을 기술해서 문제를 개선할 수 있다.
        * Cache-Control: must-revalidate, max-age=0
* Cookie 헤더를 가지고 있는 요청을 주의하라
    * 요청에 Cookie 헤더가 있으면, 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트다.
        * 개인정보는 캐시되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있다.
    * 보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것이다.
    * Set-Cookie가 있는 이미지에 대해서만 캐시를 하지만 텍스트는 캐시를 하지 않는 캐시도 있다.
        * 캐시 이미지에 파기 시간이 0인 Cookie 헤더를 설정해서 매번 재검사를 하도록 강제할 수도 있다.

#### 쿠키, 보안, 그리고 개인정보
쿠키를 사용하지 않도록 비활성화시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것도 가능하므로, 그 자체가 보안상으로 엄청나게 위험한 것은 아니다.
* 사실 원격 디비에 개인정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 하면, 예민한 데이터가 오가는 것을 줄일 수 있다.
* 개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기 때문에 항상 조심하는 것이 좋다.

쿠키에 대한 부정적이 여론이 많기는 하지만, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.