# 프락시

### 웹 중개자
웹 프락시 서버는 클라의 입장에서 트랜잭션을 수행하는 중개인
* HTTP 프락시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 하다.

#### 개인 프락시와 공유 프락시
하나의 클라가 독점적으로 사용할 수도 있고, 여러 클라가 공유할 수도 있다.

공용 프락시
* 대부분의 프락시
* 중앙 집중형 프락시를 관리하는 게 더 비용효율이 높고 쉽다.
* 캐시 프락시 서버 같은 경우 프락시를 이용하는 사용자가 많을수록 유리

개인 프락시
* 그다지 흔하지는 않지만 꾸준히 사용되고 있다.
    * 클라 컴퓨터에서 직접 실행되는 형태로
* 브라우저의 기능을 확장하거나 성능을 개선하거나 무료 ISP 서비스를 위한 광고를 운영하기 위해 작은 프락시를 사용자의 컴퓨터에서 직접 실행

#### 프락시 대 게이트웨이
프락시
* 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결

게이트웨이
* 서로 다른 프로토콜을 사용하는 둘 이상을 연결
* 클라와 서버가 다른 포로토콜로 말하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해주는 프로토콜 변환기처럼 동작

실질적으로 둘의 차이점은 모호하다.
* 프락시는 때때로 약간의 프로토콜 변환을 하기도 한다.
    * 서버와 클라의 HTTP 버전 차이
* 상용 프락시 서버는 여러가지를 지원하기 위해 게이트웨이 기능을 구현
    * SSL 보안 프로토콜
    * SOCKS 방화벽
    * FTP 접근
    * 웹 기반 애플리케이션

### 왜 프락시를 사용하는가?
프락시는 실용적이고 유용한 것이라면 무슨 일이든 한다.
* 보안을 개선
* 성능을 높여준다.
* 비용을 절약
* 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정

어린이 필터
* 초등학교는 어린이들에게 교육사이트를 제공하면서 동시에 성인 콘텐츠를 차단하는 필터링 프락시를 사용할 수 있다.

문서 접근 제어자
* 많은 웹 서버들과 웹 리소스에 대한 단일한 접근 제어 전략을 구현하고 감사 추적(audit trail)을 하기 위해 사용
    * 대기업 환경이나 그 외 분산된 관료 조직에서 유용
* 다양한 종류의 수많은 웹 서버들에 대한 접근 제어를 수시로 갱신할 필요 없이, 중앙 프락시 서버에서 접근 제어

보안 방화벽
* 보안을 강화하기 위해 프락시를 사용
* 조직 안으로 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제

웹 캐시
* 인기 있는 문서의 로컬 사본을 관리
* 해당 문서에 대한 요청이 오면 빠르게 제공
* 느리고 비싼 인터넷 커뮤니케이션을 줄인다.

대리 프락시(Surrogate)
* 웹 서버인 것처럼 위장한다
* 대리 혹은 리버스 프락시로 불리는 이들은 진짜 웹 서버 요청을 받지만 웹 서버와는 달리 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션을 시작한다.
* 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용될 수 있다.
    * 서버 가속기라고 불림
* 콘텐츠 라우팅 기능과 결합되어 주문형 복제 콘텐츠의 분산 네트워크를 만들기 위해 사용될 수 있다.

콘텐츠 라우터
* 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도
* 사용자들에게 제공할 여러 서비스를 구현하는데 사용할 수 있다.
    * 더 높은 성능을 위해 돈을 지불했다면 요청을 가까운 복제 캐시로 전달
    * 필터링 서비스에 가입했다면 필터링 프락시를 통과하도록

트랜스코더
* 콘텐츠를 클라에게 전달하기 전에 본문 포맷을 수정할 수 있다.
    * 이미지 변환
    * 텍스트 파일 압축
    * 스마트폰을 위해 작은 텍스트로 줄이기
    * 외국 문서로 변환

익명화 프락시(Anonymizes)
* HTTP 메시지에서 신원을 식별할 수 있는 특성들을 적극적으로 제거함으로써 개인 정보 보호와 익명성 보장에 기여
    * 클라 IP주소
    * From 헤더
    * Referer 헤더
    * 쿠키
    * URI 세션 아이디
* 개인 정보를 보호하기 위해 사용자의 메시지를 다음과 같이 변경
    * User-Agent 헤더에서 사용자의 컴퓨터와 OS의 종류를 제거
    * 사용자의 이메일 주소를 보호하기 위해 From 헤더 제거
    * 어떤 사이트를 거쳐서 방문했는지 알기 어렵게 하기 위해 Referer 헤더 제거
    * 프로필과 신원 정보를 없애기 위해 Cookie 헤더 제거

### 프락시는 어디에 있는가?

#### 프락시 서버 배치
어떻게 사용할지에 따라서 프락시는 어디에든 배치할 수 있다.

출구(Egress) 프락시
* 로컬 네트워크와 인터넷 사이를 오가는 트래픽을 제어하기 위해
* 회사 밖의 악의적인 해커들을 막는 방화벽을 제공하기 위해
* 인터넷 요금을 절약하고 인터넷 트래픽의 성능을 개선하기 위해
* 초등학교에서 콘텐츠 브라우징을 막기 위해

접근(입구) 프락시
* 모든 요청을 종합적으로 처리하기 위해 ISP 접근 지점에 위치하기도 한다.

대리 프락시
* 종종 대리 프락시(리버스 프락시)로 사용된다.
* 네트워크의 가장 끝에 있는 웹 서버의 바로 앞에 위치하여 모든 요청을 처리하고 필요할 때만 웹서버에게 자원을 요청한다.
* 웹 서버에 보안 기능을 추가
* 빠른 웹 서버 캐시를 놓음으로써 성능 개선

네트워크 교환 프락시
* 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고 트래픽 흐름을 감시하기 위해 사용
* 충분한 처리 능력을 갖춘 프락시가 인터넷 피어링 교환 지점에 위치하게 한다.

### 프락시 계층

#### 프락시 계층 콘텐츠 라우팅
프락시 계층들은 반드시 정적일 필요는 없다.
* 여러 가지 판단 근거에 의해 메시지를 다양하고 유동적인 프락시 서버와 원 서버들의 집합에게 보낼 수 있다.
    * 클라에 따라서 캐시 프락시로 보내거나 원 서버로 보내거나
    * 특정 종류의 이미지인 경우 압축 프락시를 통해 이미지를 가져오거나

동적 부모 선택의 몇 가지 예
* 부하 균형
    * 부하를 분산하기 위해 부모들의 작업량 수준에 근거하여 부모 프락시를 고른다.
* 지리적 인접성에 근거한 라우팅
    * 원 서버의 지역을 담당하는 부모를 선택
* 프로토콜/타입 라우팅
    * URI에 근거하여 다른 부모 프락시나 원 서버로 라우팅
* 유료 서비스 가입자를 위한 라우팅
    * 해당 가입자의 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅

동적 부모 라우팅 로직은 제품마다 다르게 구현
* 설정 파일
* 스크립트 언어
* 동적으로 실행 가능한 플러그인

#### 어떻게 프락시가 트래픽을 처리하는가
클라 트래픽이 프락시로 가도록 만드는 방법엔 4가지가 있다.

클라이언트를 수정한다.
* 많은 브라우저가 수동 혹스 자동 프락시 설정을 지원한다.

네트워크를 수정한다.
* 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가도록 조정
* 클라 모르게 트래픽을 프락시로 보내는 스위칭 장치와 라우팅 장치가 필요
* 인터셉트 프락시라 한다.

DNS 이름공간을 수정한다.
* 대리 프락시는 웹 서버의 이름과 IP 주소를 자신이 직접 사용한다.
* DNS 이름 테이블을 수동으로 편집하거나 사용할 적절한 프락시나 서버를 계산해주는 특별한 동적 DNS 서버를 이용

웹 서버를 수정한다.
* HTTP 리다이렉션 명령(상태코드 305)을 돌려줌으로써 프락시로 리다이렉트 하도록 설정

### 클라이언트 프락시 설정
모든 현대적인 브라우저는 프락시를 사용할 수 있도록 설정할 수 있다.

수동 설정
* 명시적으로 설정

브라우저 기본 설정
* 브라우저 벤더나 배포자는 브라우저를 소비자에게 전달하기 전에 미리 설정할 수 있다.

프락시 자동 설정(Proxy auto-configuration, PAC)
* 자바스크립트 PAC 파일에 대한 URI를 제공
* 클라는 프락시를 써야 하는지, 어떤 프락시를 써야하는지 자바스크립트 파일을 가져와서 실행
* 수동 프락시 설정은 유연하지 못하다, 큰 조직에서는 관리문제가 발생

WPAD 프락시 발견
* 대부분의 브라우저는 자동설정 파일을 다운받을 수 있는 ‘설정 서버’를 자동으로 찾아주는, 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol, WPAD)을 제공
* 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘
    * PAC URI를 찾기 위해 WPAD를 사용
    * 주어진 URI에서 PAC 파일을 가져온다.
    * 프락시 서버를 알아내기 위해 PAC 파일 실행
    * 알아낸 프락시에 요청

### 프락시 요청의 미묘한 특징들
웹 서버와 웹 프락시 메시지의 문법은 같지만, 한 가지 예외가 있다.
* 요청의 URI가 달라진다.
    * 웹 서버로 요청을 보낼 때는 스킴, 호스트, 포트번호가 없는 부분 URI을 가진다.
    * 프락시로 요청을 보낼 때는 완전한 URI를 가진다.
* 원래 HTTP 설계에서는 프락시에 대한 대비가 없었다.
    * HTTP/1.0은 프락시 요청에 완전한 URI를 요구하는 것으로 이 문제를 해결
    * HTTP/1.1은 웹 서버, 프락시 요청 모두 완전한 URI을 요구
    * 하지만 요청 부분의 URI 문제는 둘다 여전히 남아 있다.

#### 가상 호스팅에서 일어나는 같은 문제
가상 호스팅 되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유
* 부분 URI로 요청이 오면, 가상으로 호스팅 되는 웹 서버는 그 요청이 접근하고자 하는 웹 사이트의 호스트명을 아 필요가 있다.
* 명시적인 프락시는 완전 URI를 갖도록 해결
* 가상 호스팅 되는 웹 서버는 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더를 요구

#### 인터셉트 프락시는 부분 URI를 받는다.
클라가 HTTP를 올바르게 구현했다면, 그들은 명시적으로 설정된 프락시에게는 완전한 URI를 보낼 것이다.
* 하지만 클라는 프락시와 대화하고 있음을 항상 알고 있는 것은 아니다.
* 프락시를 사용한다고 설정 되어있지 않아도 대리 프락시나 인터셉트 프락시를 지날 수 있다.

#### 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다.
트래픽이 프락시 서버로 리다이렉트 될 수 있는 여러 가지 방법이 존재
* 다목적 프락시는 완전 URI과 부분 URI 모두 지원해야 한다.
* 완전 URI과 부분 URI를 사용하는 규칙
    * 완전한 URI가 주어지면 그것을 사용
    * 부분 URI와 Host 헤더가 있다면, Host헤더를 이용해 원 서버의 이름과 포트 번호를 알아낸다.
    * 부분 URI가 주어졌으나 Host 헤더가 없다면, 다음과 같은 방법으로 알아낸다.
        * 대리 프락시라면, 실제 서버의 주소와 포트 번호가 설정되있을 것이다.
        * 이전에 받았던 인터셉트 프락시로 부터 받았고, 원 IP주소와 포트번호를 사용하게 해두었다면 그것을 사용
    * 모두 실패했다면 에러 메시지를 반환

#### 전송 중 URI 변경
요청 URI 변경에 맹 신경을 써야 한다. 무해해 보이는 사소한 변경이라도 문제를 일으킬 수 있다.
* 몇몇 프락시는 다음 홉으로 보내기 전에 표준 형식으로 바꾸는데(포트번호 추가, 예약된 글자를 이스케이프로 변경) 이러면 안된다.
* 일반적인 프락시 서버는 가능한 한 관대하도록 애써야 한다.
* 유일한 예외는 빈 경로를 ‘/‘로 교체

#### URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)
브라우저는 프락시의 존재 여부에 따라 요청 URI를 다르게 분석
* 프락시가 없다면 URI를 가지고 그에 대응하는 IP 주소를 찾는다.
* 호스트가 발견되지 않으면 호스트 명의 ‘확장’을 제공하고자 몇가지 시도를 한다.
    * 2장의 확장
    * 서드파티 사이트로 넘겨서 오타 교정을 시도하고 URI를 제시

### 메시지 추적
프락시는 여러 벤더에 의해 개발된다. 그들은 서로 다른 기능과 버그 들을 갖고 있으며 여러 조직에 의해 관리
* 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.

#### Via 헤더
메시지가 지나는 각 중간 노드(프락시나 게이트웨이)의 정보를 나열
* 메시지가 또 다른 노드를 지날 때마다, 중간 노드는 Via 목록의 끝에 반드시 추가 되어야 한다.

프락시는 네트워크의 라우팅 루프를 탐지하기 위해 Via 헤더를 사용할 수 있다.
* 프락시는 요청을 보내기 전에 자신을 가리키는 유일한(unique) 문자열을 Via 헤더에 삽입해야 한다.
* 루프가 있는지 탐지하기 위해 이 문자열이 들어온 요청이 있는지 검사해야 한다.

Via 문법
* 쉼표로 구분된 경유지(waypoint)의 목록
* 헤더의 형식 구문은 다음과 같다. 최대 4개의 구성요소
    * 프로토콜 이름(선택, 기본은 HTTP)
        * 버전 앞에 “/“로 구분되어 붙는다.
    * 프로토콜 버전(필수)
    * 노드 이름(필수)
        * 정보 보호를 이유로 가명으로 대체 가능
    * 코멘트(선택)
        * 예를 들어 캐시 프락시 적중/비적중

Via 요청과 응답 경로
* 요청, 응답 모두 프락시를 지나므로 Via 헤더를 가진다.
    * 응답의 Via는 거의 언제나 요청의 Via 헤더와 반대

Via와 게이트웨이
* 몇몇 프락시는 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공
* via 헤더를 통해 프로토콜 변환이 있었는지를 알아챌 수 있다.

Server 헤더와 Via 헤더
* Server 헤더는 원 서버에 의해 사용되는 소프트웨어
* 프락시를 통과할 때, Server 헤더를 수정해서는 안된다.

### TRACE 메서드
프락시 서버는 메시지가 전달될 때 메시지를 바꿀 수 있다.
* 헤더 추가, 변경, 삭제
* 본문을 다른 형식으로 변환

프락시가 점점 복잡해지고 많은 벤더가 제품을 배치하면서, 상호운용성 문제가 증가한다.
* 프락시 네트워크를 쉽게 진단하기 위해, 메시지의 내용이 어떻게 변하는지 편리하게 관찰할 방법이 필요
*  HTTP/1.1의 TRACE 메서드는 요청 메시지를 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적 할 수 있도록 해준다.
    * 디버깅하는데 매우 유용하지만 널리 구현되어 있지 않다고 한다.
* TRACE 요청이 목적지 서버에 도착하면, 서버는 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함시켜 돌려보낸다.

Max-Forwards
* TRACE와 OPTIONS 요청의 프락시 홉 개수를 제한하기 위해 사용
    * 무한 루프에 빠지지 않는지 프락시 연쇄를 테스트
    * 연쇄 중간의 특정 프락시 서버들의 효과를 체크
* OPTIONS 메시지의 전달 횟수도 제한
* 이 요청 메시지가 몇 번 더 다음 홉으로 전달될 수 있는지 말해주는 정수
    * 0이라면 자신이 원 서버가 아니라 할지라도 TRACE 메시지를 더 이상 전달하지 말고 클라에게 돌려줘야 한다.
    * 받은 값이 0보다 크다면 1 감소된 값으로 갱신되어야 한다.

### 프락시 인증
접근 제어 장치로서 제공될 수 있다.
* 제한된 콘텐츠에 대한 요청이 들어오면 407 상태코드와 어떤 자격을 제출해야 하는지 Proxy-Authenticate헤더 필드와 함께 반환
* 클라는 로컬 데이터베이스를 확인하든 사용자에게 물어봐서든 요구되는 자격을 수집
* 자격을 획득하면 Proxy-Authorization 헤더 필드에 담아서 요청을 다시 보낸다.
* 요청이 유효하면 프락시는 원 요청을 통과시키고 아니면 407 응답을 보낸다.

### 프락시 상호운용성

#### 지원하지 않는 헤더와 메서드 다루기
프락시 서버는 넘어오는 헤더 필드들을 모두 이해하지 못할 수도 있다.
* 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 한다.
* 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야 한다.

#### OPTIONS: 어떤 기능을 지원하는지 알아보기
HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지(예를 들어 메서드) 클라가 알아볼 수 있게 해준다.
* 만약 URI가 별표(*)라면, 요청은, 서버 전체의 능력에 대해 묻는 것이 된다.
    * OPTIONS * HTTP/1.1
* URI가 실제 리소스라면, 특정 리소스에 대해 가능한 기능들을 묻는 것이다
* 성공한다면, 서버에서 지원하거나 지정한 리소스에 대해 가능한 선택적인 기능들을 서술하는 여러 헤더 필드를 포함한 200 OK 응답을 반환한다.
* HTTP 1.1이 명시한 헤더는 어떤 메서드가 지원되는지 서술하는 Allow 헤더 하나뿐이다.

#### Allow 헤더
요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들을 열거한다.

```
Allow: GET, HEAD, PUT
```