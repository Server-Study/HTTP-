# 기본 인증
웹의 모든 정보나 업무가 공용은 아니기 때문에, 허가된 사람만이 데이터에 접근하고 업무를 처리할 수 있어야 한다.
* 그러기 위해선 서버가 사용자가 누구인지 식별할 수 있어야 한다.
* 인증은 누구인지 증명하는 것, 보통 이름과 비밀번호를 입력해 인증
* HTTP는 자체적인 인증 관련 기능을 제공한다.
    * 요즘은 HTTP 자체 인증 기능보다는 각각의 인증 모듈을 이용해 ‘직접’ 구현한다.

### 인증
인증은 당신이 누구인지 증명하는 것
* 완벽한 인증이란 없다.
    * 비밀번호를 누군가 훔칠 수 있고, 신분증은 도둑맞거나 위조될 수 있다.
* 하지만 당신에 대한 여러 데이터는 당신이 누구인지 판단하는데 도움이 된다.

#### HTTP의 인증요구/응답 프레임워크
* HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.
* 웹 애플리케이션이 HTTP 요청을 받으면, 서버는 요청을 처리하는 대신 개인 정보를 요구하는 ‘인증 요구'로 응답할 수 있다.

#### 인증 프로토콜과 헤더
HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.
* 기본 인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다.
* HTTP 인증요구/응답 프레임워크를 사용해 새로운 프로토콜을 고안해낼 수 있다.
    * 현대에 사용하는 인증 프로토콜로는 OAuth가 있다.
* 표 12-1
    * 요청 - GET
    * 인증 요구 - WWW-Authenticate - 401 Unauthorized
        * WWW-Authenticate: Basic realm=“Family"
    * 인증 - Authorization - GET
        * Authorization: Basic YnJpYW4tdG90dHk6T3ch
    * 성공 - Authentication-Info - 200 OK
        * Authentication-Info에는 추가적인 인증 알고리즘에 대한 정보

#### 보안 영역
HTTP는 각 리소스마다 다른 접근 조건을 다루고 있다.
* 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눈다.
* WWW-Authenticate 헤더에 realm 지시자를 기술해서 인증 요구를 한다.
* 보안 영역은 저마다 다른 사용자 권한을 요구한다.

### 기본 인증
기본 인증은 가장 잘 알려진 HTTP 인증 규약이다.
* 거의 모든 주요 클라와 서버에 기본 인증이 구현되어 있다.
* 그림12-2
* 표12-2

#### Base-64 사용자 이름/비밀번호 인코딩
HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, base-64 인코딩 메서드를 사용해 인코딩한다.
* Base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환
* 예를 들어 사용자 이름이 ‘brian-totty’, 비밀번호가 ‘Ow!’일 때 콜론으로 이어서 ‘brian-totty:Ow!’를 만들고 base64로 인코딩한다.

#### 프락시 인증
중개 프락시 서버를 통해 인증할 수도 있다.
* 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증
* 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해 사용하면 좋다.
* 프락시 인증은 웹 서버의 인증과 헤더와 상태 코드만 다르고 절차는 같다.
    * 401 <-> 407
    * WWW-Authenticate <-> Proxy-Authenticate
    * Authorization <-> Proxy-Authorization
    * Authentication-Info <-> Proxy-Authentication-Info

### 기본 인증의 보안 결함
기본 인증은 단순하고 편리하지만 안심할 수는 없다.
* 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용한다.

보안 결함
* 기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송
* 디코딩하기 어렵더라도 이름과 비밀번호를 캡처해서 재전송 공격 하는 것을 예방하기 위한 어떤 일도 하지 않는다.
* 보안이 뚫리더라도 치명적이지 않은 애플리케이션에서도 굉장히 위험하다.
    * 수많은 사용자는 모든 사이트에 같은 아이디와 비밀번호를 사용
* 메시지의 인증 헤더를 건드리지는 않지만, 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿀 수 있다.
* 가짜 서버의 위장에 취약하다.

기본 인증은 일반적인 환경에서 개인화나 접근을 제어하는데 편리하며, 보지 않기를 원하는 데이터를 보더라도 치명적이지 않은 경우에 여전히 유용
* 호기심 많은 사용자가 우연이나 사고로 정보에 접근해서 보는 것을 예방하는 데 사용한다.
* 기본인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송(SSL 같은)과 함께 연계해서 사용할 수 있다.