# 엔터티와 인코딩
HTTP는 매일 수십억 개의 미디어 객체를 실어 나른다. 또한 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리되는 것을 보장한다.

구체적으로 말하면, HTTP는 다음을 보장한다.
* 객체는 올바르게 식별되므로 브라우저나 다른 클라는 콘텐츠를 바르게 처리할 수 있다.
    * Content-Type 미디어 포맷과 Content-Language 헤더를 이용
* 객체는 올바르게 압축이 풀릴 것이다.
    * Content-Length와 Content-Encoding 헤더를 이용
* 객체는 항상 최신이다.
    * 엔티티 검사기와 캐시 만료 제어를 이용
* 사용자의 요구를 만족할 것이다.
    * 내용 협상을 위한 Accept 관련 헤더를 기반하여
* 네트워크 사이를 빠르고 효율적으로 이동할 것이다.
    * 범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용
* 조작되지 않고 온전하게 도착할 것이다.
    * 전송 인코딩 헤더와 Content-MD5 체크섬을 이용

이 모든 것을 가능하게 하기 위해, HTTP는 콘텐츠를 나르기 위한 잘 라벨링 된 엔터티를 사용

### 메시지는 컨테이너, 엔터티는 화물
HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.

HTTP/1.1은 다음과 같이 10가지 주요 엔터티 헤더 필드를 정의하였다.
* Content-Type
    * 엔터티의 의해 전달된 객체의 종류
* Content-Length
    * 전달되는 메시지의 길이나 크기
* Content-Language
    * 전달되는 객체와 가장 잘 대응되는 자연어
* Content-Encoding
    * 객체 데이터에 대해 행해진 변형(압축 등)
* Content-Location
    * 요청 시점을 기준으로, 객체의 또 다른 위치
* Content-Range
    * 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
* Content-MD5
    * 엔터티 본문의 콘텐츠에 대한 체크섬
* Last-Modified
    * 서버에서 이 콘텐츠가 생성 혹은 수정된 날
* Expires
    * 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
* Allow
    * 이 리소스에 대해 어떤 요청 메서드가 허용되는지
* ETag
    * 이 인스턴스에 대한 고유한 검사기
    * 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더
* Cache-Control
    * 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자
    * ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지는 않다.

#### 엔터티 본문
엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 다른 정보들은 모두 헤더에 담겨 있다.
* 엔터티 본문은 가공되지 않은 날 데이터에 불과하기 때문에 엔터티 헤더는 그 데이터의 의미에 대해 설명할 필요가 있다.

엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

### Content-Length: 엔터티의 길이
메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
* 어떻게 인코딩 되었드 상관없이 크기를 표현
* 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.
* 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때 사용
* 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

#### 잘림 검출
옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다.
* 이 헤더가 없다면 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못한다.

메시지 잘림은 캐싱 프락시 서버에서 특히 취약하다.
* 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못했다면, 결함이 있는 콘텐츠를 캐싱하게 된다.
* 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐싱하지 않는다.

#### 잘못된 Content-Length
잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다.
* 공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어 있다.

#### Content-Length와 지속 커넥션(Persistent Connection)
지속 커넥션을 위해 필수다. 만약 응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것이다.
* 클라에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

#### 콘텐츠 인코딩
HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해준다.
* 본문의 콘텐츠가 인코딩 되어 있다면, Content-Length는 인코딩된 본문의 길이를 바이트 단위로 정의한다.
* 불행히도 HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 원 본문의 길이를 위해 사용될 수 없다.
    * 클라가 수행항 디코딩 과정에 문제 없는지 검증하게 어렵게 만든다.

#### 엔터티 본문 길이 판별을 위한 규칙
다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙
* 본문을 갖는 것이 허용되지 않은 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다.
    * 이 경우 실제 본문 길이를 서술하지 않는다.
* 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0 바이트 청크’라는 특별한 패턴으로 끝나야 한다.
* 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
* 메시지가 ‘multipart/byteranges’ 미디어 타입을 사용하고 엔터티 깅리가 별도로 정의되지 않았다면(Content-Length 헤더로), 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다.
    * 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형
    * 따라서 수신자가 해석할 수 있다는 사실을 알기 전까지는 절대로 보내면 안된다.
* 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
* HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.
    * 1.1 명세는 본문은 있지만, Content-Length 헤더가 없다면 400 응답을 보내거나 본문 길이를 알고 싶다면 411 Length Required 응답을 보내라고 조언하고 있다.

### 엔터티 요약
TCP/IP와 같이 신뢰할 만한 프로토콜 위에서 구현됨에도, 불완전한 프락시나 버그 많은 중개자 프락시 등의 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
* 엔티티 본문의 의도하지 않은 변경을 감지하기 위해, 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 체크섬으로 기본적인 검사를 할 수 있다.
    * 본문, 헤더 모두 교체하는 악의적인 공격에는 면역력이 없다.
    * 오직 의도치 않은 변경을 감지하기 위한 것
* Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용
* 오직 응답을 처음 만든 서버만이 Content-MD5 헤더를 계산해서 보낼 것이다.
* Content-MD5 헤더는, 콘텐츠 인코딩의 적용은 끝났지만 전송 인코딩은 아직 적용하지 않은 엔터티 본문에 대한 MD5를 담고 있다.
    * 클라는 전송 인코딩을 먼저 디코딩 하고 디코딩 된 엔터티 본문에 대해 MD5를 계산해야 한다.
* 메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.

### 미디어 타입과 차셋(Charset)
Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
* MIME 타입은 주 미디어 타입(텍스트, 이미지, 오디오)으로 시작해서 뒤이어 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입(subtype)으로 구성된다.
> MIME 타입 : 전달되는 데이터 매체의 기저 형식(HTML, 워드, MPEG 비디오 등)의 표준화된 이름

#### 텍스트 매체를 위한 문자 인코딩
선택적인 매개변수도 지원한다.
* 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 ‘charset’ 매개변수가 대표적인 예
```
Content-Type: text/html; charset=iso-8859-4
```

#### 멀티파트 미디어 타입
MIME “멀티파트” 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
* 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함
* 여러 구성요소들이 문자열 하나로 서로의 경계가 식별

### 콘텐츠 인코딩
HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 한다.
* 전송 시간을 줄이기 위해 압축
* 제삼자가 볼 수 없도록 암호화하거나 뒤섞어 보낼 수도 있다.

### 콘텐츠 인코딩 과정
* 웹서버가 원본 응답 메시지를 생성
* 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성
    * Content-Type은 같지만 Content-Length는 다르다.
    * Content-Encoding 헤더를 인코딩 메시지에 추가하여, 수신 측이 디코딩 할 수 있도록 한다.
* 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.
* 그림 15-3

#### 콘텐츠 인코딩 유형
HTTP는 몇 가지 표준 콘텐츠 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
* 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화

#### Accept-Encoding 헤더
클라는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.
* 해당 헤더를 포함하지 않는다면, 어떤 인코딩이든 받아들일 수 있는 것으로 간주
    * Accept-Encoding: * 의 경우와 같다.
* 클라는 각 인코딩에 Q(quality) 값을 매개변수로 더해 선호도를 나타낼 수 있다.

### 전송 인코딩과 청크 인코딩
콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다.
* 텍스트 파일은 gzip으로 압축이 되지만 JPEG 파일은 잘 gzip으로 잘 압축되지 않는다.

전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.
* 메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있다.
* 그림 15-5

#### 안전한 전송
표준화되고 더 너그러운 전송 기반을 갖춘 HTTP는 ‘안전한 전송’의 초점을 다른 데에 맞추고 있다.
* HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 몇 가지 밖에 없다.

알수 없는 크기
* 콘텐츠를 먼저 생성하지 않고서는 본문의 최종 크기를 판단할 수 없다.
* 흔히 이 서버들은 그 사이즈를 알기 전에 데이터의 전송을 시작하려 하낟.
* 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.
    * 지속 커넥션이 망가진다.

보안
* 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법도 있다.
* 그러나 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안이 흔하지 않다.

#### Transfer-Encoding 헤더
전송 인코딩을 제어하기 위한 정의된 헤더는 단 두개 뿐이다.
* Transfer-Encoding
    * 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
* TE
    * 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용
    * Accept-Encoding 헤더와 마찬가지로 어떤 전송 인코딩을 선호하는지 표현하는 Q 값을 가질 수 있다.

#### 청크 인코딩
청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다.
* 서버는 각 청크를 순차적으로 보낸다.
* 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없다.
* 전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성이다.
    * 멀티파트 인코딩은 본문의 속성이며 청크 인코딩과는 완전히 분리 되어 있다.

청크와 지속 커넥션
클라와 서버 사이에 지속 커넥션이 아니면, 클라는 서버가 커넥션을 닫을 때까지 본문으로 간주하고 읽으면 된다.

지속 커넥션에서는, 본문을 쓰기 전에 반드시 Content-Length 헤더를 담아서 보내줘야 한다. 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보냄으로써 이 딜레마에 대한 해법을 제공한다.
* 서버는 동적으로 본문이 생성되서 모두 보낼때까지 반복하고, 크기가 0인 청크로 본문이 끝났음을 알린다음 커넥션을 열린채로 유지할 수 있다.
* HTTP 응답 헤더 블록으로 시작하고, 각 청크는 CRLF로 분리, 마지막 청크는 길이가 0
* 그림 15-6

청크 인코딩된 메시지의 트레일러
다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.
* 클라의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
* 트레일러가 응답을 만든 서버에 의해 추가되었으며, 클라가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라가 무시하고 버려도 되는 경우
* 메시지 헤더는 청크 인코딩된 메시지 다음에 오게 될 헤더들을 나열하는 Trailer 헤더를 포함
    * 청크들이 동적으로 생성되기 때문에 모든 청크를 만들고 나서 보낸다.
* 마지막 청크 다음에 Trailer 헤더에 나열했던 헤더들이 온다.
* Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 헤더도 트레일러로 보낼 수 있다.

#### 콘텐츠와 전송 인코딩의 조합
콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
* 그림 15-7

#### 전송 인코딩 규칙
전송 인코딩이 메시지 본문에 적용될 때, 몇 가지 규칙이 반드시 적용되어야 한다.
* 전송 인코딩 집합은 반드시 ‘chunked’를 포함해야 한다.
    * 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우
* 청크 전송 인코딩이라면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
* 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

### 시간에 따라 바뀌는 인스턴스
웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.
* HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것은 인스턴스 조작(instance manipluation)이라 불리며 객체의 인스턴스에 작용한다.
    * 대표적인 두 가지가 범위 요청과 델타 인코딩
* 그림 15-8

### 검사기와 신선도
처음 요청에서 응답을 캐시한다. 그리고 문서가 클라에서 만료되면 클라는 반드시 서버에게 최신 사본을 요구해야 한다.
* 조건부 요청이라고 불리는 이 특별한 요청은, 클라가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것

#### 신선도
서버는 얼마동안 콘텐츠가 신선하다고 가정할 수 있는지에 대한 정보를 준다.
* Expires 헤더는 만료되는 정확한 날짜를 명시
    * 클라나 서버는, 그들의 시계를 반드시 동기화시켜야 한다.
* Cache-Control 헤더는 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다.
    * 수명은 시계 동기화에 의존하지 않으므로 더 정확한 결과를 말해준다.
    * 더 많은 지시자들과 함께, 단지 수명이나 유효기간뿐 아니라 신선도를 서술하기 위해 사용한다.
    * 표 15-3

#### 조건부 요청과 검사기
캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있다.
* HTTP는 클라에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 방법을 제공한다.
* 표 15-4 에 요청 유형이 정의

HTTP는 검사기를 약한 검사기와 강한 검사기 두 가지로 분류
* 약한 검사기는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우도 있다.
    * 객체의 바이트 단위 크기
* 강한 검사기는 언제나 고유하게 식별
    * 콘텐츠에 대한 암호 체크섬

### 범위 요청
HTTP는 클라가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.
* 범위 요청을 이용하면, HTTP 클라는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.
    * 원 서버의 객체가 아무 변경이 없어야 한다.

```
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4,61 [en] (winNT; I)
...
```

클라가 4000바이트 이후의 부분을 요청하고 있다.
* 문서의 크기는 모르기 때문에 몇 바이트까지인지는 명시하지 않는다.

모든 서버가 범위 요청을 받아들일 수 있는 것은 아니지만 많은 경우 가능하다.
* 서버는 클라에게 자신이 범위를 받아들일 수 있는지 응답에 Accept-Range 헤더를 포함시키는 방법으로 알려줄 수 있다.

Range 헤더는 피어 투 피어 파일 공유 클라가 멀티미디어 파일의 다른 부분을 여러 다른 피어로부터 동시에 다운로드 받을 때도 널리 사용

### 델타 인코딩
델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다.
* 변경된 페이지가 있을 때 전체 페이지를 보내는 대신, 페이지에 대한 클라의 사본(변경량이 작은)에 대해 변경된 부분만을 서버가 보낸다면 클라는 더 빨리 페이지를 얻을 수 있다.
* 그림 15-10

#### 인스턴스 조작, 델타 생성기 그리고 델타 적용기
클라는 A-IM 헤더를 이용해서 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다. 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다.
* 표 15-6에 인스턴스 조작의 종류를 나열하고 있다.

델타 인코딩 명세는 A-IM과 IM 헤더의 포맷을 자세히 정의한다.
* 여기서는 이 헤더들에서 복수 개의 인스턴스 조작들을 지정할 수 있다.
* 클라에게 반환되기 전에 압축률을 극대화하기 위해 여러 번의 인스턴스 조작을 거칠 수 있다.

델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기가 까다로울 수 있다.
* 서버는 자신이 제공하는 페이지가 변경되는 매 순간의 사본을 모듀 유지하고 있어야 한다.
* 전송량 감소로 얻은 이득을 금방 무의미하게 만들 수도 있다.