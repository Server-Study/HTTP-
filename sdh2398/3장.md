# 3장 HTTP 메시지

### 메시지의 흐름
HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록
* 데이터의 블록은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작
* 그 다음에 선택적 데이터가 온다.
* 메시지는 클라, 서버, 프락시 사이를 흐르고 다음은 메시지의 방향을 의미하는 용어
    * 인바운드
    * 아웃바운드
    * 업스트림
    * 아웃스트림

메시지는 원 서버 방향으로 인바운드로 하여 송신된다.

HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용
* 메시지가 원 서버로 향하는 것을 인바운드
* 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것을 아웃바운드

다운스트림으로 흐르는 메시지
요청, 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.
* 메시지의 발송자는 수신자의 업스트림이다.
* 메시지가 어느방향으로 가는 것에 대한게 아니라 어느 방향이든 다운스트림이다.

### 메시지의 각 부분
메시지는 시작줄, 헤더 블록, 본문으로 이루어진다.
* 시작줄 - 어떤 메시지인지 서술
* 헤더 - 속성
* 본문 - 데이터가 있거나 아예 없을 수도 있다.

시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.
* 캐리지 리턴과 개행 문자(CRLF)
* HTTP명세에 따르면 CRLF지만 그냥 개행 문자도 받아들일 수 있어야 견고한 애플리케이션
    * 오래되거나 잘못 만들어진 애플리케이션은 CR과 LF를 모두 항상 전송하지 않은 것도 있다.

#### 메시지 문법
모든 HTTP 메시지는 요청, 응답 메시지로 분류된다.

요청 메시지
```
<메서드><요청 URL><버전>
<헤더>

<엔티티 본문>
```

응답 메시지
```
<버전><상태 코드><사유 구절>
<헤더>

<엔티티 본문>
```

메서드

클라 측에서 서버가 리소스에 대해 수행해주길 바라는 동작

요청 URL

요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소
* 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주

버전

이 메시지에서 사용 중인 HTTP의 버전
* HTTP/<메이저>.<마이너>
* 메이저, 마이너 모두 정수

상태 코드

요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자
* 첫 번째 자릿수는 상태의 일반적인 분류

사유 구절

상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
* 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절
* 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재
* 사유 구절이 달라도 상태 코드가 같으면 같은 방식으로 처리되어야 한다.

헤더들

이름, 콜론, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더
* 1.1과 같은 몇몇 버전은 요청이나 응답에 어떤 특정 헤더가 포함되어야 유효한 것으로 간주

엔티티 본문

임의의 데이터 블록을 포함
* 모든 메시지가 본문을 갖는 것은 아니기 때문에, 때때로 그냥 CRLF로 끝나게 된다.
* 많은 클라, 서버가 엔티티 본문이 없는 경우에 실수로 CRLF를 빠드린다.
* 규칙을 잘 지키지 않는 구현체와 호환을 위해 CRLF없이 끝나는 메시지도 받아들일 수 있어야 한다.

#### 시작줄
요청 메시지는 무엇을 해야 하는지, 응답 메시지는 무슨 일이 일어났는지 말해준다.

요청줄

서버에게 리소스에 대해 무언가를 해달라고 부탁한다.
* 어떤 동작이 일어나야 하는지의 메서드, 대상을 지칭하는 요청URL, 버전

응답줄

메시지를 수행한 결과에 대한 상태 정보와 결과 데이터를 클라에게 돌려준다.
* 버전, 상태코드 사유 구절

메서드

HTTP 명세는 공통 요청 메서드의 집합을 정의한다.
* 모든 서버가 모든 메서드를 구현한 것은 아니다.

상태 코드

상태 코드는 각 응답 메시지의 시작줄에 담겨 반환된다.
* 숫자로 된 코드, 문자열로 되어 있는 메시지 모두 반환

사유 구절

응답 시작줄의 마지막 구성요소
* 사유 구절은 상태 코드와 일대일로 대응된다.
* HTTP 명세는 사유 구절이 어때야 한다는 어떤 엄격한 규칙도 제공하지 않는다.

버전 번호

HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단
* 대화 상대의 능력과 메시지의 형식에 대한 단서를 제공
* 버전 번호는 분수로 다루어지지 않는다.
    * HTTP/2.22는 HTTP/2.3보다 크다.

#### 헤더
HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다.
* 기본적으로 이름/값 쌍의 목록이다.

헤더 분류

HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 또한 자유롭게 자신만의 헤더를 만들어 낼 수 있다.
* 일반 헤더
    * 요청과 응답 양쪽에 모두 나타날 수 있음
* 요청 헤더
    * 요청에 대한 부가 정보를 제공
* 응답 헤더
    * 응답에 대한 부가 정보를 제공
* Entity 헤더
    * 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
* 확장 헤더
    * 명세에 정의되지 않은 새로운 헤더

헤더를 여러 줄로 나누기

긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.
```
HTTP/1.0 200 OK
Content-Type: image/gif
Server: Test Server
    Version 1.0
```

Server 헤더의 완전한 값을 'Test Server Version 1.0'이다.

#### 엔티티 본문
HTTP 메시지의 세 번째 부분은 선택적인 엔티티 본문이다.

#### 버전 0.9메시지
요청은 그저 메서드와 요청 URL만 갖고 있고, 응답은 엔티티로만 되어 있다.
* 그 당시 유일한 버전이었기 때문에 버전 정보가 없다.
* HTTP/0.9로는 다양한 상황에 대응할 수 없다.
* 0.9를 사용하는 클라, 서버, 기타 애플리케이션들이 있기 때문에 제약에 대하 알아놔야 한다.

### 메서드
모든 서버가 모든 메서드를 구현하지는 않는다.
* HTTP/1.1과 호환되고자 한다면, GET, HEAD 메서드만을 구현하는 것으로 충분하다.

#### 안전한 메서드(Safe Method)
HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다.
* GET, HEAD메서드는 안전하다고 볼 수 있는데, 이 메서드의 요청은 결과로 서버에 어떤 작용도 없음을 의미
* 작용이 없다는 건, 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 것
* 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장이 없다.
    * 사실 웹 개발자에게 달렸다.

#### GET
주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.
* HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구한다.

#### HEAD
GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.
* 엔티티 본문은 결코 반환되지 않는다.
* 리소스를 가져오지 않고도 그에 대해 무엇인가(타입같은것)를 알아낼 수 있다.
* 응답의 상태 코드를 통해, 개체가 존재하는지 확인 가능
* 헤더를 확인하여 리소스가 변경되었는지 검사

서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

#### PUT
PUT 메서드는 서버에 문서를 쓰기위해 사용한다.
* 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만든다.
* 이미 존재한다면 본문을 사용해서 교체한다.
* PUT은 콘텐츠를 변경할 수 있게 해주기 때문에, 많은 웹서버가 비밀번호를 입력해서 로그인 하도록 요구한다.

#### POST
서버에 입력 데이터를 전송하기 위해 설계되었다.

#### TRACE
클라가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다.
* 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.

TRACE 요청은 목적지 서버에서 ‘루프백(loopback)’ 진단을 시작한다.
* 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE응답을 되돌려준다.
* 클라와 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지 확인할 수 있다.
* 또한 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다.

TRACE는 메서드를 구별하는 메커니즘을 제공하지 않는다.
* 어떻게 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션이 결정을 내린다.

#### OPTIONS
웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
* 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.
* 몇몇 서버는 특정 종류의 객체에 대해 특정 동작만을 지원한다.

#### DELETE
지정한 리소스를 삭제할 것을 요청
* 클라는 삭제가 수행되는 것을 보장하지 못한다.
* HTTP 명세는 서버가 클라에게 알리지 않고 요청을 무시하는 것을 허용하기 때문
* 클라는 그냥 리소스가 지워졌다고 생각하게 된다.

#### 확장 메서드
HTTP/1.1에 정의 되어 있지 않은 메서드
* 개발자들에게 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.
* 확장 메서드에 대해 관용적인 것이 최고다.

### 상태 코드
클라에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

#### 100-199 : 정보성 상태 코드
HTTP/1.1에 도입되었다.
* 비교적 새로운 것이며, 복잡함을 감수할 만한 가치가 있는지에 대한 논란이 되고 있다.

100 Continue
* 요청의 시작 부분 일부가 받아들여졌으며, 클라는 나머지를 계속 이어서 보내야 한다.
* 이것을 보낸 후 서버는 반드시 요청을 받아 응답해야 한다.
* 서버가 엔티티를 받아들일 것인지 확인하기위해 도입

101 Switching Protocols
*  클라가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸엇음을 의미

클라와 100 Continue

클라가 엔티티를 서버에게 보내려고 하고, 그 전에 100 Continue 응답을 기다리겠다면, 100-continue로 하는 Expect 요청 헤더를 보낼 필요가 있다
* 클라가 엔티티를 보내지 않으려 한다면 Expect헤더를 보내지 말아야 한다.(서버가 혼란에 빠질수 있기 때문)
* 100-continue값이 담긴 Expect 헤더를 보낸 클라는 응답을 막연히 기다리지 말고 약간의 타임아웃 후 엔티티를 보내야 한다.

서버와 100 Continue

서버가 100-Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100-continue 응답 혹은 에러 코드로 답해야 한다.
* 서버는 절대로 100-continue 응답을 받을 것을 의도하지 않은 클라에게 100 Continue 상태 코드를 보내서는 안된다.
* 서버가 100 Continue 응답을 하기 전에 엔티티를 수신하였따면, 해당 응답 코드(100)는 보낼 필요가 없고 엔티티를 다 읽은 후에는 최종 응답을 보내야 한다.

프락시와 100 Continue

클라로부터 100 Continue 응답을 의도한 요청을 받는다면 몇 가지 해야 할 일이 있다.
* 다음 홉(next-hop) 서버가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모르면, Expect 헤더를 포함시켜 다음으로 전달
* 1.1 이전의 버전을 따른다는 것을 알면 417 Expectation Failed 에러로 응답
* 프락시가 다음 홉 서버들에 대한 상태 몇 가지와 그들이 지원하는 HTTP 버전을 기억해둔다면 프락시에게 이득이 된다.

#### 200-299: 성공 상태 코드
클라가 요청을 보내면, 그 요청은 대개 성공한다.

200 OK
* 요청은 정상이고, 엔티티 본문은 요청된 리소스를 포함

201 Created
* 서버 개체를 생성하라는 요청
* 응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더
* 그 리소스를 참조할 수 있는 여러 URL을 엔티티 본문에 포함
* 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.

202 Accepted
* 요청은 받아들였으나, 아직 그에 대한 어떤 동작도 수행하지 않음
* 서버가 요청의 처리 완료를 보장해주지 않는다.
* 서버는 엔티티 본문에 언제 완료될 것인지에 대한 추정도 포함해야 한다.

203 Non-Authoritative Information
* 엔티티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다는 뜻
* 중개자가 리소스의 사본을 갖고있지만 검증하지 못한 경우 발생
* 원래 서버에서 왔다면 200 상태였을 것이다.

204 No Content
* 헤더와 상태줄은 포함하지만 엔티티 본문은 포함하지 않는다.
* 주로 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용
    * 폼을 리프레시

205 Reset Content
* 주로 브라우저에서 사용
* 브라우저에게 현재 페이지에 있는 폼에 채워진 모든 값을 비우라고 말한다.

206 Partial Content
* 부분 혹은 범위 요청이 성공
* Content-Range와 Date 헤더를 반드시 포함
* Etag와 Content-Location 중 하나의 헤더도 반드시 포함

#### 300-399: 리다이렉션 상태 코드
리다이렉션 상태 코드는 클라가 관심있어 하는 리소스에 대해 다른 위치를 사용하거나 그 리소스의 내용 대신 다른 대안 응답을 제공
* 만약 리소스가 옮겨졌다면 어디서 찾을 수 있을지 리다이렉션 코드와 (선택적으로) Location 헤더를 보낸다.

리다이렉션 상태 코드 중 몇몇은 리소스에 대한 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용한다.
* If-Modified-Since 헤더를 전송하여 그 날짜 이후에 변한 것이 없다면, 서버는 콘텐츠 대신 304 상태 코드로 답할 것이다.

300 Multiple Choices
* 클라가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 리소스 목록과 함께 반환
* HTML 문서를 영어와 프랑스어 모두로 제공하는 경우 등에 사용

301 Moved Permanently
* 요청한 URL이 옮겨졌을 때 사용
* 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.

302 Found
* 301 상태 코드와 같다.
* 클라는 Location 헤더로 주어진 URL 리소스를 임시로 가리키기 위한 목적으로 사용
* 이후 요청에서는 원래 URL을 사용해야 한다.

303 See Other
* 클라에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 사용
* 새 URL은 Location 헤더에 있다.
* 주 목적은 POST 요청에 대한 응답으로 클라에게 리소스의 위치를 알려주는 것

304 Not Modified
* 클라는 헤더를 이용해 조건부 요청을 만들 수 있다.
* 리소스가 어느 날짜 이후 수정되었는가 같은 조건
* 엔티티 본문을 가져서는 안 된다.

305 Use Proxy
* 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용.
* 프락시의 위치는 Location 헤더를 통해 주어진다.

306
* 사용 되지 않는다.

307 Temporary Redirect
* 301 상태 코드와 비슷
* 클라는 Location 헤더로 주어진 URL 리소스를 임시로 가리키기 위한 목적으로 사용
* 이후 요청에서는 원래 URL을 사용해야 한다.

302, 303, 307 상태 코드 사이에서 중복된 부분이 많다.
* 이는 주로 HTTP/1.0과 HTTP/1.1 애플리케이션이 이 상태코드를 다루는 방식의 차이점에 기안한다.
* HTTP/1.0은 클라가 POST요청을 보내고 302 상태 코드를 받으면 Location에 들어있는 URL로 GET요청을 한다.
* HTTP/1.1에서는 리다이렉션을 위해 303 상태 코드를 사용한다.
* 이 혼란을 막기 위해 HTTP/1.1 명세는 클라의 일시적인 리다이렉트를 위해 302 대신 307을 사용하라고 한다.

#### 400-499: 클라이언트 에러 상태 코드
가끔 클라는 서버가 다룰 수 없는 무엇인가를 보낸다.
* 잘못 구성된 메시지
* 가장 흔한 것이 존재 하지 않는 URL에 대한 요청

400 Bad Request
* 클라가 잘못된 요청을 보냈다고 말해준다.

401 Unauthorized
* 리소스를 얻기 전에 스스로를 인증하라고 요구한다.
* 적절한 헤더와 함께 반환

402 Payment Required
* 현재는 쓰지 않는다.
* 미래에 사용될 가능성이 있다.

403 Forbidden
* 요청이 서버에 의해 거부되었음을 알려준다.
* 거부 이유를 설명하는 엔티티 본문을 포함할 수 있다.
* 그러나 보통 거절의 이유를 숨기고 싶을 때 사용

404 Not Found
* 서버가 요청한 URL을 찾을 수 없을을 위해 사용

405 Method Not Allowed
* 요청한 URL에 대해, 지원하지 않는 메서드로 요청을 받았을 때 사용
* 요청한 리소스에 대해 어떤 메서드가 사용 가능한지 알려주기 위해 Allow 헤더가 포함된다.

406 Not Acceptable
* 클라는 자신이 어떤 종류의 엔티티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다.
* URL에 대한 리소스 중 클라가 받아들일 수 있는 것이 없는 경우 사용

407 Proxy Authentication Required
* 401 상태코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용

408 Request Timeout
* 클라의 요청을 완수하기에 시간이 너무 많이 거릴는 경우 이 상태 코드로 응답하고 연결을 끊을 수 있다.

409 Conflict
* 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용
* 응답은 충돌에 대해 설명하는 본문을 포함해야 한다.

410 Gone
* 404와 비슷하나, 서버가 한 때 그 리소스를 갖고 있었다는 점이 다르다.
* 주로 웹사이트를 유자보수하면서, 클라에게 릿스가 제거된 경우 이를 알려주기 위해 사용

411 Length Required
* 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용

412 Precondition Failed
* 클라가 조건부 요청을 했는데 그 중 하나가 실패했을 때 사용
* 조건부 요청은 클라가 Expect 헤더를 포함했을 때 발새한다.

413 Request Entity Too Large
* 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라가 보냈을 때 사용

414 Request URI Too Long
* 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라가 보냈을 때 사용

415 Unsupported Media Type
* 서버가 이해하거나 지원하지 못하는 내용 유형의 엔티티를 보냈을 때 사용

416 Request Range Not Satisfiable
* 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었거나 맞지 않을 때 사용

417 Expectation Failed
* 요청에 포함된 Expect 헤더에 서버가 만족시킬 수 없는 기대가 담겨 있을 경우 사용
* 프락시나 다른 중개나 애플리케이션은, 원 서버가 요청의 기대를 만족시킬 수 없을 명확한 증거가 있다면 이 응답 코드를 전송할 수 있다.

#### 500-599: 서버 에러 상태 코드
클라가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우

500 Internal Server Error
* 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용

501 Not Implemented
* 클라가 서버의 능력을 넘은 요청을 했을 때 사용
* 예로 서버가 지원하지 않는 메서드를 사용
* 405 vs 501 ?
* 405 - https://tools.ietf.org/html/rfc7231#section-6.5.5
    * 405는 원래 사용 가능한 메소드로 알려져 있지만 해당 리소스에 대해 지원이 불가능한 경우
* 501 - https://tools.ietf.org/html/rfc7231#section-6.6.2
    * 서버가 해당 요청을 수행하는데 필요한 기능을 지원하지 않음, 서버가 요청방법을 인식하지 못하고 지원할 수 없는 경우

502 Bad Gateway
* 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용

503 Service Unavailable
* 현재는 요청을 처리해줄 수 없지만 나중에 가능함을 의미하고자 할 때 사용
* 만약 서버가 언제 그 리소스를 사용할 수 있게 될지 알 고 있다면, Retry-After 헤더를 응답에 포함

504 Gateway Timeout
* 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다.

505 HTTP Version Not Supported
* 지원할 수 없거나 지원하지 않으려는 버전의 프로토콜로 된 요청을 받았을 때 사용
* 몇몇 서버 애플리케이션들은 오래된 버전의 프로토콜은 지원하지 않을 것을 택한다.

### 헤더
헤더와 메서드는 클라와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.
* 특정 종류의 메시지에만 사용할 수 있는 헤더
* 더 일반 목적으로 사용할 수 있는 헤더
* 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더

#### 일반 헤더(General Headers)
* 클라와 서버 양쪽 모두가 사용
* 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용
* 예를 들어 Date 헤더는 메시지가 만들어진 일시를 지칭하기 위해 사용

일반 캐시 헤더

HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입

Cache-Control
* 메시지와 함께 캐시 지시자를 전달하기 위해 사용

Pragma
* 메시지와 함께 지시자를 전달하는 또 다른 방법
* 캐시에 국한되지 않는다.
* 엄밀히 말하면 요청헤더, 응답 헤더의 흔한 오용때문에 응답 헤더로 해석하지만 사실 엄밀한 의미는 잘 정의되어 있지 않다.
* Cache-Control로 인해 Deprecated될 예정

#### 요청 헤더(Request Headers)
* 요청을 위한 헤더
* 서버에게 클라가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공
* 예를 들어 Accept 헤더는 자신의 요청에 대응하는 미디어 타입을 지칭

요청 메시지에서만 의미를 갖는 헤더
* 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보
* 클라이언트의 선호나 능력에 대한 정보
* 서버는 클라에게 더 나은 응답을 주기 위해 활용

Accept 관련 헤더

서버와 클라 양쪽 모두에게 유익하다.
* 클라는 그들이 원하는 것을 얻을 수 있다.
* 서버는 클라가 사용할 수도 없는 것을 전송하는 데 시간과 대역폭을 낭비하지 않을 수 있다.

조건부 요청 헤더

때때로, 클라는 요청에 몇몇 제약을 넣기도 한다.
* 클라는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하는 제약을 포함시킬 수 있다.

요청 보안 헤더

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다.
* 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 만들고자 한다.

프락시 요청 헤더

인터넷에서 프락시가 점점 흔해지면서, 그들의 기능을 돕기 위해 몇몇 헤더들이 정의되었다.

#### 응답 헤더(Response Headers)
* 응답 메시지는 클라에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.
* 예를 들어 Server 헤더는 어떤 종류의 서버와 대화하고 있는가

응답 헤더들은 클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 할 수 있도록 도와준다.

협상 헤더

서버에 프랑스어와 독일어로 번역이 HTML 문서가 있는 경우와 같이 여러 가지 표현이 가능한 상황이라면, HTTP/1.1은 서버와 클라가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있다.

응답 보안 헤더

HTTP 인증요구/응답 체계에서 응답 측에 해당

#### 엔티티 헤더(Entity Headers)
* 엔티티 본문에 대한 헤더
* 엔티티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다.
    * Content-Type 헤더

엔티티에 대해 설명하는 헤더
* 요청과 응답 양쪽 메시지 모두 나타날 수 있다.
* 엔티티와 그것의 내용물에 대한, 개체의 타입
* 주어진 리소스에 대해 요청할 수 있는 유효한 메서드
* 메시지 수신자에게 자신이 다루고 있는 것이 무엇인지 말해준다.

콘텐츠 헤더

엔티티의 콘텐츠에 대한 구체적인 정보를 제공
* 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들

엔티티 캐싱 헤더

엔티티 캐싱 헤더는 엔티티 캐싱에 대한 정보를 제공
* 일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공
* 리소스에 대해 캐시된 사본이 아직 유효한지
* 캐시된 리소스가 더 이상 유효하지 않게 되는 시점

#### 확장 헤더(Extension Headers)
* 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더
