# 통합점: 게이트웨이, 터널, 릴레이

HTTP는 웹에 있는 모든 리소스에 대한 프로토콜로 사용됐으며, 애플리케이션 간에 서로 다른 프로토콜을 상호 운용하는 용도로 사용하기도 한다.
* 게이트웨이 : 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
* 애플리케이션 인터페이스 : 서로 다른 형식의 웹 애플리케이션이 통신하는 데 사용한다.
* 터널 : HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하는데 사용한다.
* 릴레이 : 일종의 단순한 HTTP 프락시로, 한 번에 한 개의 홉에 데이터를 전달하는데 사용한다.

### 게이트웨이
웹에 더 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것은 분명해졌다
* 이 문제에 대한 해결책으로, 인터프리터 같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트웨이를 고안해냈다.
* 게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.
* 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다.
    * HTTP/FTP 게이트웨이 : FTP URL을 가리키는 HTTP 요청을 받아서 게이트웨이는 FTP 서버에서 문서를 받아 클라에 내려준다.
    * HTTPS/HTTP 게이트웨이 : 암호화된 웹 요청을 SSL을 통해 받고, 요청을 해독해 일반 HTTP 요청을 목적지 서버로 전달한다.
    * HTTP/CGI 게이트웨이 : 애플리케이션 서버 게이트웨이 API를 통해서 HTTP 클라를 서버측 애플리케이션 프로그램에 연결한다.
        * 웹에서 물건을 사거나 일기예보, 주식시세를 볼 때, 사실은 애플리케이션 서버 게이트웨이를 방문한 것

#### 클라이언트 측 게이트웨이와 서버 측 게이트웨이
게이트웨이는 클라 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로 구분해 기술한다.
* <클라 프로토콜>/<서버 프로토콜>
* 게이트웨이가 어느 쪽 역할을 하고 있는지 설명하기 위해서 ‘서버 측 게이트웨이’와 ‘클라 측 게이트웨이’라는 용어를 사용
    * 서버 측 게이트웨이 : 클라와 HTTP 통신하고, 서버와는 외래 프로토콜로 통신
    * 클라 측 게이트웨이 : 클라와 외래 프로토콜로 통신하고, 서버와는 HTTP와 통신

### 프로토콜 게이트웨이
프락시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.
* 보통 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리 서버(리버스 프락시)로 설정할 수 있다
* 브라우저는 일반적인 HTTP 트래픽은 원 서버로 바로 보낸다.
* FTP URL 게이트웨이를 설정하면 FTP URL을 포함한 요청은 해당 게이트웨이로 HTTP 요청을 보낸다.
    * 게이트웨이는 클라측 요청을 FTP 요청으로 변환하여 처리한 뒤 클라에게 HTTP로 결과를 전송한다.

#### HTTP/* : 서버 측 웹 게이트웨이
서버 측 웹 게이트웨이는 클라로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라 측의 HTTP 요청을 외래 프로토콜로 전환한다.
* 게이트웨이는 객체를 받는 대로 HTTP 응답에 실어서 클라에 전송할 것이다.

#### HTTP/HTTPS : 서버 측 보안 게이트웨이
기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있다.
* 클라는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화할 것이다.

#### HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이
HTTPS/HTTP 게이트웨이는 보안 가속기로 유명하다.
* 웹 서버의 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다.
* 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.
* 요즘에는 인프라가 좋아져서 대부분 SSL 암/복호화 모듈을 내장한다.
* 로드 밸런서 중에는 SSL 모듈을 내장하여 HTTPS/HTTP 게이트웨이 역할을 해주는 것도 있다.

### 리소스 게이트웨이
게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다.
* 애플리케이션 서버는 HTTP를 통해서 클라와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이

애플리케이션 게이트웨이에서 유명했던 최초의 API는 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)였다.
* CGI는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP 응답으로 회산하는데 웹 서버가 사용하는 표준화된 인터페이스의 집합
* 게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리

#### 공용 게이트웨이 인터페이스
공용 게이트웨이 인터페이스(CGI)는 최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장.
* 웹에서 동적인 HTML, 신용카드 처리, DB 질의 등을 제공하는데 사용

CGI가 내부에서 어떤 처리를 하는지는 사용자에게 보이지 않는다.
* 사용자의 시각에서 CGI가 내부적으로 일반적인 요청을 만드는 것일 뿐이다.
* 서버와 CGI 애플리케이션 간에 진행되는 처리 단계를 감춘다.
* CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공
* 모든 CGI 요청마다 새로운 프로세스를 만드는 데 따르는 부하가 꽤 크다.

### 서버 확장 API
CGI 프로토콜은 구동 중인 HTTP 서버에 외부 인터프리터가 쉽게 접속할 수 있게 해준다.
* 서버 자체의 동작을 바꾸고 싶거나 서버의 처리능력을 최고치로 끌어올리고자 할 때는 웹 개발자가 자신의 모듈을 HTTP와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API를 제공

### 애플리케이션 인터페이스와 웹 서비스
웹 애플리케이션이 더 많은 형식의 서비스를 제공함에 따라, HTTP가 애플리케이션을 연결하는 도구로 활용할 수 있다는 게 더 확실해졌다.
* 애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나는, 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일
* HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있다.
    * HTTP 확장의 몇 가지 예나 HTTP의 위에 프로토콜을 덧씌워 사용자 맞춤 정보를 교환

### 터널
웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공
* HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있다.
* 다른 프로토콜을 HTTP 위에 올릴 수 있다.
* 웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서다.
* 웹 터널을 사용하면 웹 트래픽만을 허락하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다.

#### CONNECT로 HTTP 터널 커넥션 맺기
웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.
* CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라와 서버 간에 오는 데이터를 무조건 전달하기를 요청

CONNECT 요청
* CONNECT 문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같다.
* 시작 줄 다음에는 다른 HTTP 메서드와 같이, 요청 헤더 필드가 있거나 없다.

```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/4.0
```

CONNECT 응답
* 일반 HTTP 메시지와 같이 200 응답 코드는 성공을 뜻한다.
* Content-Type 헤더를 포함할 필요는 없다.
    * 커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문에 콘텐츠 형식이 필요가 없다.

```
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1
```

#### 데이터 터널링, 시간, 커넥션 관리
터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.
* 클라는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있다.
    * 서버에 데이터를 더 빨리 보내는 방법이지만, 게이트웨이가 요청에 이어서 데이터를 적절하게 처리할 수 있어야 한다.
* 터널 끝단 어느 부분이든 커넥션이 끊기면 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려진다.

#### SSL 터널링
웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었다.
* SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프락시에서는 처리되지 않는다.
* 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP 만을 허용하는 방화벽을 통과 시킬 수 있다.
* 터널링 기능은 HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 전송된다.
* 터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다.
    * 하지만 터널은 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있다.

#### SSL 터널링 vs HTTP/HTTPS 게이트웨이
HTTPS 프로토콜은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할 수 있다.
* 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이(클라 대신)를 두고 클라 측의 HTTPS 트랜잭션을 수행하는 방식
* 응답은 프락시가 받아서 복호화하고 난 후에, HTTP를 통해 클라로 전송한다.
    * 게이트웨이가 FTP를 처리하는 방식과 같다.
* 이 접근에는 몇 가지 단점이 있다.
    * 클라-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어진다.
    * 프락시가 인증을 담당하고 있기 때문에, 클라는 원격 서버에 SSL 클라 인증을 할 수 없다.
    * 게이트웨이는 SSL을 완벽히 지원해야 한다.

SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없다.
* SSL 세션은 클라가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성된다.
* 프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링 할 뿐이다.

#### 터널 인증
HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다.
* 특히 프락시 인증 기능은, 클라가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.
* 그림 8-13
    * 게이트웨이에 CONNECT 요청을 전송
    * 클라에 인증요구를 반환
    * 적절한 인증과 함께 CONNECT 요청을 전송
    * 게이트웨이와 웹 서버가 443포트로 SSL 커넥션을 연다.
    * 커넥션이 맺어진다.
    * 클라에 HTTP 커넥션 준비 메시지를 반환

#### 터널 보안에 대한 고려사항들
보통, 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없다.
* 짓궃은 직원이 게임을 하려고 회사 방화벽에 터널을 생성하여 게임 트래픽을 사내로 유입시킬 수 있다.
* 악의적인 사용자가 회사에 텔넷 세션을 열어 회사의 이메일 차단 장치를 우회하려고 터널을 열 수 있다.
* 터널의 오용을 최소화하기 위해, 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링 할 수 있게 허용해야 한다.

### 릴레이
HTTP 릴레이는 HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시다.
* 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달한다.
* 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽을 전달하는 간단한 프락시를 구현하는 방식이 유용할 때가 있다.
    * 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 주의해서 배포해야 한다.
* 단순한 맹목적 릴레이를 구현하는데 관련된 더 일반적인(악명 높은) 문제 중 하나는, 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행(hang)에 걸리는 것이다.
    * 4.5.6장의 Keep-Alive와 멍청한(dumb) 프락시와 같음